{"version":3,"sources":["migrateTimestamps.js","CypherViz.js","App.js","serviceWorker.js","index.js"],"names":["migrateTimestamps","driver","a","session","console","log","run","timestamp","Date","now","error","close","CypherViz","startBreathingAnimation","breathingInterval","clearInterval","setInterval","state","isUserActive","fgRef","current","timelineMode","triggerBreathingCycle","stopBreathingAnimation","breathingState","expandNodes","contractNodes","graph","currentStrength","strengthIncrement","rampUpForce","d3Force","d3","strength","d3ReheatSimulation","setTimeout","rampDuration","strengthDecrement","rampDownForce","updateUserActivity","wasActive","setState","lastUserActivity","scaleTransitionStart","forceUpdate","idleTimeout","clearTimeout","checkIdleAndReturnToDefault","processingMutation","customQueryActive","customQueryTimeout","loadData","defaultQuery","startIdleDetection","forEach","event","document","addEventListener","idleCheckInterval","stopIdleDetection","removeEventListener","addTimestampsToMutationQuery","query","trimmedQuery","trim","test","isNFCOperation","processedQuery","replace","match","alias","properties","newProperties","endsWith","slice","nameMatch","name","setClause","includes","newSetClause","source","target","newNodeName","queryOverride","database","isCustomQuery","queryToExecute","pendingNFCNode","isMutationQuery","validStartKeywords","queryStart","toUpperCase","some","keyword","startsWith","alert","res","mutationReloadTimeout","pendingNode","focusOnNewNode","data","nodes","links","nodesMap","Map","records","record","has","get","set","role","location","website","x","Math","random","y","push","warn","keys","key","node","identity","low","u_name","u_role","u_location","u_website","Array","from","values","updatedData","find","n","currentDataHash","calculateDataHash","hasChanged","lastDataHash","hasDetailedChange","isInitialLoad","hasDataChanged","isDataIdentical","JSON","stringify","localStorage","setItem","timeSinceLastUpdate","lastUpdateTime","forceUpdateForNFC","updateDebounceTime","updateCount","maxUpdatesPerCycle","nodeToSet","latestNode","changedNodesFromPolling","length","firstChangedNode","focusOnPollingNode","pollingFocusTimeout","pollingFocusNode","nodeName","graphData","attemptFocus","attempt","newNode","centerAt","zoom","focusOnMultipleNodes","nodeNames","nodesStr","map","sort","join","linksStr","l","newData","oldData","changedNodes","hasChanges","oldNodesMap","oldNode","oldLinksSet","Set","newLink","startPolling","pollingInterval","isPolling","hidden","updateCountResetInterval","stopPolling","connectWebSocket","disconnectWebSocket","websocket","wsConnected","useWebSocket","addNodeNFC","newUser","nfcUserName","capitalizedNewUser","capitalizeWords","str","split","word","charAt","toLowerCase","capitalizedNfcUser","user","checkExistingUser","nodeToFocus","duplicateCheck","duplicateCount","toNumber","allNodes","bestRole","bestLocation","bestWebsite","createdAt","nfcUser","checkCount","waitForStateUpdate","nodeExists","refreshTimelineStats","nfcNodeForAutoPopup","handleChange","newQuery","value","resetQuery","validateAndCleanQuery","currentQuery","onNfcPopupTriggered","toggleTimelineMode","getTimelineStats","stats","validStats","earliest","latest","prevState","timelineDate","timelineData","timelineStats","loadTimelineData","date","getTime","result","sourceRole","targetRole","sourceLocation","targetLocation","sourceWebsite","targetWebsite","add","updateTimelineDate","earliestDate","convertTimestamp","numTimestamp","Number","minValid","maxValid","secondsTimestamp","latestDate","resetToCurrentTime","newTimelineDate","React","createRef","defaultData","breathingAnimation","scaleTransitionDuration","this","handleVisibilityChange","path","element","addNode","Component","NFCTrigger","useLocation","username","useParams","useEffect","toString","substr","window","assign","addAndRedirect","style","textAlign","padding","fontSize","color","GraphView","useState","inputValue","setInputValue","selectedNode","setSelectedNode","editedNode","setEditedNode","focusNode","setFocusNode","clickedNode","setClickedNode","lastAction","setLastAction","mutatedNodes","setMutatedNodes","analyticalAnswer","setAnalyticalAnswer","showAnalyticalModal","setShowAnalyticalModal","relationshipNote","setRelationshipNote","nfcNameInput","setNfcNameInput","nfcRoleInput","setNfcRoleInput","showNfcNamePopup","setShowNfcNamePopup","showProfilePopup","setShowProfilePopup","pendingNfcName","setPendingNfcName","selectedLink","setSelectedLink","relationshipData","setRelationshipData","showNfcRelationshipPopup","setShowNfcRelationshipPopup","currentNfcConnection","setCurrentNfcConnection","hoveredLink","setHoveredLink","focusTimeout","setFocusTimeout","autoZoomTriggered","setAutoZoomTriggered","nfcNode","neighbors","link","getOneDegreeNodes","getNDegreeNodes","startNode","degree","visited","currentLevel","d","nextLevel","sourceName","targetName","visibilityFocus","zoomFocus","visibilityNodes","filter","neighbor","zoomNodes","searchMatches","searchNodes","mutationNodes","size","performAutoZoom","visibleNodes","xs","ys","minX","min","maxX","max","minY","maxY","centerX","centerY","width","height","scale","innerWidth","innerHeight","newFocusTimeout","handleSubmit","e","preventDefault","fetch","method","headers","body","question","response","json","generatedQuery","text","isNodeReportRequest","pattern","isReportRequest","isTrueAnalyticalQuestion","toObject","fuzzyResult","suggestions","displayNetworkReport","report","generateNodeReport","generateNetworkReport","answer","generateAnalyticalAnswer","displayAnalyticalAnswer","extractedNodes","deleteMatches","Boolean","matchClause","nodeMatches","handleLinkClick","relationshipResult","note","handleLinkHover","handleEditChange","prev","saveRelationshipNote","holderName","fallbackResult","existingName","nfcHolderResult","nfcHolderName","updateResult","handleNfcNameSubmit","capitalizedName","existingNodeCheck","existingNode","visitorName","saveNewProfileFromNfc","newName","questionLower","count","locations","uniqueLocations","roles","uniqueRoles","names","resultCount","connections","users","userConnections","connectionNote","connectionTime","time","topConnectors","entries","b","u","connector","index","round","recordCount","nodeInfo","connectedUsers","otherPerson","otherRole","otherLocation","totalConnections","roleCounts","topRoles","Object","locationCounts","topLocations","c","formattedReport","htmlReport","isHtml","type","placeholder","display","margin","border","borderRadius","onChange","input","onKeyPress","id","onClick","open","position","bottom","left","transform","backgroundColor","boxShadow","zIndex","minWidth","alignItems","gap","marginBottom","newDate","cursor","step","parseInt","flex","toLocaleDateString","toLocaleTimeString","hour","minute","justifyContent","second","marginTop","top","right","animation","maxWidth","maxHeight","overflow","stopPropagation","background","dangerouslySetInnerHTML","__html","overflowY","ref","nodeId","nodeLabel","linkLabel","onNodeClick","onNodeHover","onLinkClick","onLinkHover","onBackgroundClick","nodeCanvasObject","ctx","isHighlighted","isNDegree","globalAlpha","nodeRadius","floor","transitionProgress","breathingScale","sin","fillColor","currentColorShift","colorShift","fillStyle","strokeStyle","lineWidth","beginPath","arc","PI","fill","stroke","shadowBlur","firstName","fillText","linkColor","isConnected","linkOpacity","linkCurvature","linkDirectionalArrowRelPos","linkDirectionalArrowLength","marginRight","href","substring","minHeight","resize","fontStyle","App","className","hostname","neo4j","process","NEO4J_URI","basic","NEO4J_USER","NEO4J_PASSWORD","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.361b5948.chunk.js","sourcesContent":["// Migration script to add timestamps to existing data\r\n// Run this once to add createdAt properties to existing nodes and relationships\r\n\r\nconst migrateTimestamps = async (driver) => {\r\n  const session = driver.session();\r\n  try {\r\n    console.log('Starting timestamp migration...');\r\n    \r\n    // Add createdAt to nodes that don't have it\r\n    const nodeResult = await session.run(\r\n      `MATCH (u:User)\r\n       WHERE u.createdAt IS NULL\r\n       SET u.createdAt = $timestamp\r\n       RETURN count(u) as updatedNodes`,\r\n      { timestamp: Date.now() }\r\n    );\r\n    \r\n\r\n    \r\n    // Add createdAt to relationships that don't have it\r\n    const relResult = await session.run(\r\n      `MATCH ()-[r:CONNECTED_TO]->()\r\n       WHERE r.createdAt IS NULL\r\n       SET r.createdAt = $timestamp\r\n       RETURN count(r) as updatedRelationships`,\r\n      { timestamp: Date.now() }\r\n    );\r\n    \r\n\r\n    \r\n\r\n    \r\n  } catch (error) {\r\n    console.error('Error during timestamp migration:', error);\r\n  } finally {\r\n    session.close();\r\n  }\r\n};\r\n\r\nexport default migrateTimestamps;\r\n","import React, { useState, useEffect } from 'react';\r\nimport { HashRouter as Router, Route, Routes, useLocation, useParams } from 'react-router-dom';\r\nimport './App.css';\r\nimport ForceGraph2D from 'react-force-graph-2d';\r\nimport * as d3 from 'd3';\r\nimport migrateTimestamps from './migrateTimestamps';\r\n\r\nclass CypherViz extends React.Component {\r\n  constructor({ driver }) {\r\n    super();\r\n    this.driver = driver;\r\n    this.fgRef = React.createRef();\r\n    \r\n    this.defaultData = {\r\n      nodes: [],\r\n      links: []\r\n    };\r\n    \r\n    this.state = {\r\n      data: this.defaultData,\r\n      query: `MATCH (u:User)-[r:CONNECTED_TO]->(v:User) \r\n          RETURN u.name AS source, u.role AS sourceRole, u.location AS sourceLocation, u.website AS sourceWebsite, \r\n      v.name AS target, v.role AS targetRole, v.location AS targetLocation, v.website AS targetWebsite`,\r\n      latestNode: null, // For NFC editing\r\n      pollingFocusNode: null, // For polling focus (non-editable)\r\n      lastUpdateTime: null,\r\n      isPolling: false,\r\n      useWebSocket: false,\r\n      wsConnected: false,\r\n      customQueryActive: false,\r\n      customQueryTimeout: null,\r\n      processingMutation: false,\r\n      lastUserActivity: Date.now(),\r\n      isUserActive: true,\r\n      nfcNodeForAutoPopup: null, // For auto-popup form on NFC tap\r\n      timelineMode: false, // Timeline mode toggle\r\n      timelineDate: null, // Current timeline date\r\n      timelineData: null, // Timeline-specific data\r\n    };\r\n\r\n    // Store the default query for polling (separate from user input)\r\n    this.defaultQuery = `MATCH (u:User)-[r:CONNECTED_TO]->(v:User) \r\n        RETURN u.name AS source, u.role AS sourceRole, u.location AS sourceLocation, u.website AS sourceWebsite, \r\n        v.name AS target, v.role AS targetRole, v.location AS targetLocation, v.website AS targetWebsite`;\r\n\r\n    // Store the last known data hash for change detection\r\n    this.lastDataHash = null;\r\n    this.pollingInterval = null;\r\n    this.websocket = null;\r\n    this.lastUpdateTime = 0;\r\n    this.updateDebounceTime = 2000; // 2 seconds debounce\r\n    this.updateCount = 0;\r\n    this.maxUpdatesPerCycle = 3; // Prevent infinite loops\r\n    this.mutationReloadTimeout = null;\r\n    this.idleTimeout = null;\r\n    this.idleCheckInterval = null;\r\n    this.isNFCOperation = false; // Flag to prevent double reload during NFC operations\r\n    this.changedNodesFromPolling = []; // Track nodes changed during polling\r\n    this.isInitialLoad = true; // Flag to prevent focusing on initial load\r\n    this.pollingFocusTimeout = null; // Timeout to clear polling focus\r\n    this.breathingAnimation = null; // For breathing animation\r\n    this.breathingState = 'expanded'; // 'contracted' or 'expanded'\r\n    this.breathingInterval = null; // Interval for breathing cycle\r\n    this.scaleTransitionStart = null; // For smooth scaling transition\r\n    this.scaleTransitionDuration = 1000; // 1 second transition\r\n\r\n  }\r\n\r\n  // Breathing animation methods\r\n  startBreathingAnimation = () => {\r\n    if (this.breathingInterval) {\r\n      clearInterval(this.breathingInterval);\r\n    }\r\n    \r\n    // Start breathing cycle every 4 seconds\r\n    this.breathingInterval = setInterval(() => {\r\n      if (!this.state.isUserActive && this.fgRef.current && !this.state.timelineMode) {\r\n        this.triggerBreathingCycle();\r\n      }\r\n    }, 4000); // 4 second cycle\r\n  };\r\n\r\n  stopBreathingAnimation = () => {\r\n    if (this.breathingInterval) {\r\n      clearInterval(this.breathingInterval);\r\n      this.breathingInterval = null;\r\n    }\r\n    \r\n    // Reset to expanded state when stopping and clean up forces\r\n    if (this.fgRef.current && this.breathingState === 'contracted') {\r\n      this.expandNodes();\r\n    }\r\n  };\r\n\r\n  triggerBreathingCycle = () => {\r\n    if (this.breathingState === 'expanded') {\r\n      this.contractNodes();\r\n    } else {\r\n      this.expandNodes();\r\n    }\r\n  };\r\n\r\n  contractNodes = () => {\r\n    if (!this.fgRef.current) return;\r\n    \r\n    this.breathingState = 'contracted';\r\n    \r\n    // Get the current graph instance\r\n    const graph = this.fgRef.current;\r\n    \r\n    // Start with very low strength and gradually increase for smooth transition\r\n    let currentStrength = 0.01;\r\n    const targetStrength = 0.05;\r\n    const rampDuration = 2000; // 2 seconds to ramp up\r\n    const rampSteps = 20;\r\n    const strengthIncrement = (targetStrength - currentStrength) / rampSteps;\r\n    const stepInterval = rampDuration / rampSteps;\r\n    \r\n    const rampUpForce = () => {\r\n      if (currentStrength < targetStrength) {\r\n        currentStrength += strengthIncrement;\r\n        graph.d3Force('breathing-attraction', d3.forceRadial(0, 0, 10).strength(currentStrength));\r\n        graph.d3ReheatSimulation();\r\n        setTimeout(rampUpForce, stepInterval);\r\n      }\r\n    };\r\n    \r\n    // Start the gradual ramp-up\r\n    rampUpForce();\r\n    \r\n    // After 10 seconds, expand back (5x slower)\r\n    setTimeout(() => {\r\n      this.expandNodes();\r\n    }, 10000);\r\n  };\r\n\r\n  expandNodes = () => {\r\n    if (!this.fgRef.current) return;\r\n    \r\n    this.breathingState = 'expanded';\r\n    \r\n    // Get the current graph instance\r\n    const graph = this.fgRef.current;\r\n    \r\n    // Gradually reduce the breathing force for smooth expansion\r\n    const currentForce = graph.d3Force('breathing-attraction');\r\n    if (currentForce) {\r\n      let currentStrength = 0.05;\r\n      const rampDuration = 2000; // 2 seconds to ramp down\r\n      const rampSteps = 20;\r\n      const strengthDecrement = currentStrength / rampSteps;\r\n      const stepInterval = rampDuration / rampSteps;\r\n      \r\n      const rampDownForce = () => {\r\n        if (currentStrength > 0.001) {\r\n          currentStrength -= strengthDecrement;\r\n          graph.d3Force('breathing-attraction', d3.forceRadial(0, 0, 10).strength(currentStrength));\r\n          graph.d3ReheatSimulation();\r\n          setTimeout(rampDownForce, stepInterval);\r\n        } else {\r\n          // Completely remove the force when it's very small\r\n          graph.d3Force('breathing-attraction', null);\r\n          graph.d3ReheatSimulation();\r\n        }\r\n      };\r\n      \r\n      // Start the gradual ramp-down\r\n      rampDownForce();\r\n    }\r\n  };\r\n\r\n  // Update user activity timestamp\r\n  updateUserActivity = () => {\r\n    const now = Date.now();\r\n    const wasActive = this.state.isUserActive;\r\n    \r\n    this.setState({ \r\n      lastUserActivity: now,\r\n      isUserActive: true \r\n    });\r\n    \r\n    // If user just became active, stop breathing animation and start scale transition immediately\r\n    if (!wasActive) {\r\n      this.stopBreathingAnimation();\r\n      // Capture the exact breathing state at this moment to prevent jitter\r\n      this.scaleTransitionStart = now;\r\n      // Force an immediate re-render to start the transition\r\n      this.forceUpdate();\r\n    }\r\n    \r\n    // Clear existing idle timeout\r\n    if (this.idleTimeout) {\r\n      clearTimeout(this.idleTimeout);\r\n    }\r\n    \r\n    // Set new idle timeout (5 seconds of inactivity)\r\n    this.idleTimeout = setTimeout(() => {\r\n      this.setState({ isUserActive: false });\r\n      // Start breathing animation when user becomes idle\r\n      this.startBreathingAnimation();\r\n    }, 5000); // 5 seconds of inactivity\r\n  };\r\n\r\n  // Check if user is idle and should return to default query\r\n  checkIdleAndReturnToDefault = () => {\r\n    // Don't interfere if a mutation is being processed\r\n    if (this.state.processingMutation) {\r\n      return;\r\n    }\r\n    \r\n    if (this.state.customQueryActive && !this.state.isUserActive) {\r\n      this.setState({ \r\n        customQueryActive: false, \r\n        customQueryTimeout: null \r\n      });\r\n      \r\n      // Clear any existing timeout\r\n      if (this.state.customQueryTimeout) {\r\n        clearTimeout(this.state.customQueryTimeout);\r\n      }\r\n      \r\n      // Reload with default query\r\n      this.loadData(null, this.defaultQuery);\r\n    }\r\n  };\r\n\r\n  // Start idle detection system\r\n  startIdleDetection = () => {\r\n    // Set up activity listeners\r\n    const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];\r\n    \r\n    activityEvents.forEach(event => {\r\n      document.addEventListener(event, this.updateUserActivity, true);\r\n    });\r\n    \r\n    // Check for idle state every 2 seconds\r\n    this.idleCheckInterval = setInterval(() => {\r\n      this.checkIdleAndReturnToDefault();\r\n    }, 2000);\r\n    \r\n    // Initial activity update\r\n    this.updateUserActivity();\r\n  };\r\n\r\n  // Stop idle detection\r\n  stopIdleDetection = () => {\r\n    const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];\r\n    \r\n    activityEvents.forEach(event => {\r\n      document.removeEventListener(event, this.updateUserActivity, true);\r\n    });\r\n    \r\n    if (this.idleCheckInterval) {\r\n      clearInterval(this.idleCheckInterval);\r\n      this.idleCheckInterval = null;\r\n    }\r\n    \r\n    if (this.idleTimeout) {\r\n      clearTimeout(this.idleTimeout);\r\n      this.idleTimeout = null;\r\n    }\r\n  };\r\n\r\n  // Add timestamps to mutation queries automatically\r\n  addTimestampsToMutationQuery = (query) => {\r\n    if (!query || typeof query !== 'string') return query;\r\n    \r\n    const trimmedQuery = query.trim();\r\n    const timestamp = Date.now();\r\n    \r\n    // Check if this is a mutation query\r\n    const isMutationQuery = /(CREATE|MERGE|SET|DELETE|REMOVE|DETACH DELETE)/i.test(trimmedQuery);\r\n    if (!isMutationQuery) return query;\r\n    \r\n    // Skip processing if this is an NFC operation to prevent duplicate timestamps\r\n    if (this.isNFCOperation) {\r\n      console.log('Skipping timestamp processing for NFC operation');\r\n      return query;\r\n    }\r\n    \r\n    console.log(`Processing mutation query with timestamps: ${query}`);\r\n    \r\n    let processedQuery = query;\r\n    \r\n    // Add timestamps to CREATE User operations\r\n    processedQuery = processedQuery.replace(\r\n      /CREATE\\s*\\(([^:]+):User\\s*\\{([^}]*)\\}\\)/gi,\r\n      (match, alias, properties) => {\r\n        // Remove existing createdAt if present\r\n        const cleanProperties = properties.replace(/createdAt\\s*:\\s*[^,}]+/g, '');\r\n        // Add timestamp - handle trailing comma and closing brace properly\r\n        let newProperties = cleanProperties.trim();\r\n        if (newProperties.endsWith(',')) {\r\n          newProperties = newProperties.slice(0, -1); // Remove trailing comma\r\n        }\r\n        newProperties = `${newProperties}, createdAt: ${timestamp}`;\r\n        \r\n        // Extract name property for MERGE matching\r\n        const nameMatch = properties.match(/name\\s*:\\s*['\"]([^'\"]+)['\"]/);\r\n        if (nameMatch) {\r\n          const name = nameMatch[1];\r\n          // Use MERGE with name only, then set other properties on CREATE\r\n          return `MERGE (${alias}:User {name: '${name}'}) ON CREATE SET ${alias}.createdAt = ${timestamp}`;\r\n        }\r\n        \r\n        return `CREATE (${alias}:User {${newProperties}})`;\r\n      }\r\n    );\r\n    \r\n    // Add timestamps to MERGE User operations with ON CREATE\r\n    processedQuery = processedQuery.replace(\r\n      /MERGE\\s*\\(([^:]+):User\\s*\\{([^}]*)\\}\\)\\s*ON CREATE SET\\s*([^}]*)/gi,\r\n      (match, alias, properties, setClause) => {\r\n        // Add createdAt to ON CREATE SET if not present\r\n        if (!setClause.includes('createdAt')) {\r\n          let newSetClause = setClause.trim();\r\n          if (newSetClause.endsWith(',')) {\r\n            newSetClause = newSetClause.slice(0, -1); // Remove trailing comma\r\n          }\r\n          newSetClause = `${newSetClause}, ${alias}.createdAt = ${timestamp}`;\r\n          return `MERGE (${alias}:User {${properties}}) ON CREATE SET ${newSetClause}`;\r\n        }\r\n        return match;\r\n      }\r\n    );\r\n    \r\n    // Add timestamps to relationship creation (various patterns)\r\n    // Pattern 1: CREATE (a)-[:CONNECTED_TO]->(b)\r\n    processedQuery = processedQuery.replace(\r\n      /CREATE\\s*\\(([^)]+)\\)-\\[:CONNECTED_TO\\]->\\(([^)]+)\\)/gi,\r\n      (match, source, target) => {\r\n        return `CREATE (${source})-[r:CONNECTED_TO]->(${target}) SET r.createdAt = ${timestamp}`;\r\n      }\r\n    );\r\n    \r\n    // Pattern 2: CREATE (a)-[r:CONNECTED_TO]->(b)\r\n    processedQuery = processedQuery.replace(\r\n      /CREATE\\s*\\(([^)]+)\\)-\\[([^:]+):CONNECTED_TO\\]->\\(([^)]+)\\)/gi,\r\n      (match, source, alias, target) => {\r\n        return `CREATE (${source})-[${alias}:CONNECTED_TO]->(${target}) SET ${alias}.createdAt = ${timestamp}`;\r\n      }\r\n    );\r\n    \r\n    // Pattern 3: MERGE (a)-[:CONNECTED_TO]->(b) ON CREATE SET\r\n    processedQuery = processedQuery.replace(\r\n      /MERGE\\s*\\(([^)]+)\\)-\\[:CONNECTED_TO\\]->\\(([^)]+)\\)\\s*ON CREATE SET\\s*([^}]*)/gi,\r\n      (match, source, target, setClause) => {\r\n        if (!setClause.includes('createdAt')) {\r\n          let newSetClause = setClause.trim();\r\n          if (newSetClause.endsWith(',')) {\r\n            newSetClause = newSetClause.slice(0, -1); // Remove trailing comma\r\n          }\r\n          newSetClause = `${newSetClause}, r.createdAt = ${timestamp}`;\r\n          return `MERGE (${source})-[r:CONNECTED_TO]->(${target}) ON CREATE SET ${newSetClause}`;\r\n        }\r\n        return match;\r\n      }\r\n    );\r\n    \r\n    // Pattern 4: MERGE (a)-[r:CONNECTED_TO]->(b) ON CREATE SET\r\n    processedQuery = processedQuery.replace(\r\n      /MERGE\\s*\\(([^)]+)\\)-\\[([^:]+):CONNECTED_TO\\]->\\(([^)]+)\\)\\s*ON CREATE SET\\s*([^}]*)/gi,\r\n      (match, source, alias, target, setClause) => {\r\n        if (!setClause.includes('createdAt')) {\r\n          let newSetClause = setClause.trim();\r\n          if (newSetClause.endsWith(',')) {\r\n            newSetClause = newSetClause.slice(0, -1); // Remove trailing comma\r\n          }\r\n          newSetClause = `${newSetClause}, ${alias}.createdAt = ${timestamp}`;\r\n          return `MERGE (${source})-[${alias}:CONNECTED_TO]->(${target}) ON CREATE SET ${newSetClause}`;\r\n        }\r\n        return match;\r\n      }\r\n    );\r\n    \r\n    // Pattern 5: MERGE (a)-[:CONNECTED_TO]->(b) (without ON CREATE)\r\n    processedQuery = processedQuery.replace(\r\n      /MERGE\\s*\\(([^)]+)\\)-\\[:CONNECTED_TO\\]->\\(([^)]+)\\)/gi,\r\n      (match, source, target) => {\r\n        return `MERGE (${source})-[r:CONNECTED_TO]->(${target}) ON CREATE SET r.createdAt = ${timestamp}`;\r\n      }\r\n    );\r\n    \r\n    // Pattern 6: MERGE (a)-[r:CONNECTED_TO]->(b) (without ON CREATE)\r\n    processedQuery = processedQuery.replace(\r\n      /MERGE\\s*\\(([^)]+)\\)-\\[([^:]+):CONNECTED_TO\\]->\\(([^)]+)\\)(?!\\s*ON CREATE)/gi,\r\n      (match, source, alias, target) => {\r\n        return `MERGE (${source})-[${alias}:CONNECTED_TO]->(${target}) ON CREATE SET ${alias}.createdAt = ${timestamp}`;\r\n      }\r\n    );\r\n    \r\n    console.log(`Processed mutation query with timestamps: ${processedQuery}`);\r\n    return processedQuery;\r\n  };\r\n\r\n  loadData = async (newNodeName = null, queryOverride = null) => {\r\n\r\n    let session = this.driver.session({ database: \"neo4j\" });\r\n    let res;\r\n    \r\n    // Determine which query to use\r\n    let queryToExecute = queryOverride;\r\n    let isCustomQuery = false;\r\n    \r\n    if (!queryToExecute) {\r\n      // For polling, use default query unless a custom query is active\r\n      if (newNodeName === null && !queryOverride && !this.state.customQueryActive) {\r\n        queryToExecute = this.defaultQuery;\r\n      } else {\r\n        // For user-initiated queries, use state.query but validate it\r\n        queryToExecute = this.state.query;\r\n        isCustomQuery = true;\r\n      }\r\n    } else if (queryOverride !== this.defaultQuery) {\r\n      // If a custom query is being executed\r\n      isCustomQuery = true;\r\n    }\r\n    \r\n    // Special handling for NFC operations - if we have a pending NFC node, \r\n    // we should use the default query to reload the graph after mutation\r\n    if (newNodeName && this.pendingNFCNode && newNodeName === this.pendingNFCNode) {\r\n      queryToExecute = this.defaultQuery;\r\n      isCustomQuery = false;\r\n    }\r\n    \r\n\r\n    \r\n    // Check if this is a mutation query BEFORE determining if it's custom\r\n    const isMutationQuery = /(CREATE|MERGE|SET|DELETE|REMOVE|DETACH DELETE)/i.test(queryToExecute.trim());\r\n    \r\n    // If it's a mutation query, it should never be treated as a custom query\r\n    if (isMutationQuery) {\r\n      isCustomQuery = false;\r\n    }\r\n    \r\n    // Validate the query\r\n    if (!queryToExecute || typeof queryToExecute !== 'string' || queryToExecute.trim() === '') {\r\n      console.error(\"Invalid query:\", queryToExecute);\r\n      return;\r\n    }\r\n    \r\n    // Check if query starts with valid Cypher keywords\r\n    const validStartKeywords = ['MATCH', 'CREATE', 'MERGE', 'DELETE', 'SET', 'RETURN', 'WITH', 'UNWIND', 'CALL'];\r\n    const queryStart = queryToExecute.trim().toUpperCase();\r\n    const isValidQuery = validStartKeywords.some(keyword => queryStart.startsWith(keyword));\r\n    \r\n    if (!isValidQuery) {\r\n      return;\r\n    }\r\n    \r\n    // Block DELETE operations for user safety\r\n    const isDeleteQuery = /(DELETE|DETACH DELETE|REMOVE)/i.test(queryToExecute.trim());\r\n    if (isDeleteQuery) {\r\n      alert('DELETE operations are not allowed for safety reasons. Please use other operations like CREATE, MERGE, or SET.');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      // Preprocess mutation queries to add timestamps\r\n      let processedQuery = queryToExecute;\r\n      if (isMutationQuery && !this.isNFCOperation) {\r\n        processedQuery = this.addTimestampsToMutationQuery(queryToExecute);\r\n      }\r\n  \r\n      res = await session.run(processedQuery);\r\n      \r\n              // Handle mutations for ALL queries (not just custom ones)\r\n        if (isMutationQuery) {\r\n        // For mutation queries, immediately return to default query\r\n        \r\n        // Force return to default state regardless of idle detection\r\n        this.setState({ \r\n          customQueryActive: false, \r\n          customQueryTimeout: null,\r\n          processingMutation: true,\r\n          isUserActive: true // Temporarily mark as active to prevent idle interference\r\n        });\r\n        \r\n        // Clear any existing timeout\r\n        if (this.state.customQueryTimeout) {\r\n          clearTimeout(this.state.customQueryTimeout);\r\n        }\r\n        \r\n        // Prevent multiple mutation reloads\r\n        if (this.mutationReloadTimeout) {\r\n          clearTimeout(this.mutationReloadTimeout);\r\n        }\r\n        \r\n        // Store the pending NFC node before reloading\r\n        const pendingNode = this.pendingNFCNode;\r\n        \r\n        // For NFC operations, don't trigger another reload since addNodeNFC already handles it\r\n        if (this.isNFCOperation) {\r\n          // Skip additional reload for NFC operations\r\n        } else if (!this.state.processingMutation) {\r\n          // Immediately reload with default query to show updated graph\r\n          this.loadData(pendingNode, this.defaultQuery);\r\n        }\r\n        \r\n        this.setState({ processingMutation: false });\r\n        this.mutationReloadTimeout = null;\r\n        \r\n        // For NFC operations, focusing is handled in addNodeNFC, so skip here\r\n        if (pendingNode && !this.isNFCOperation) {\r\n          setTimeout(() => {\r\n            this.focusOnNewNode(pendingNode, this.state.data);\r\n            this.pendingNFCNode = null;\r\n          }, 1500);\r\n        } else if (this.isNFCOperation) {\r\n          // NFC operation - focusing will be handled by addNodeNFC\r\n        } else {\r\n          // Reset NFC operation flag if no pending node\r\n          this.isNFCOperation = false;\r\n        }\r\n        \r\n        // Reset user activity state after a short delay to allow idle detection to work normally\r\n        setTimeout(() => {\r\n          this.updateUserActivity();\r\n        }, 100);\r\n        \r\n        // Return early to prevent processing mutation query results\r\n        return;\r\n      } else if (isCustomQuery) {\r\n        // For non-mutation custom queries, activate custom query state\r\n        this.setState({ customQueryActive: true });\r\n        \r\n        // Clear any existing timeout\r\n        if (this.state.customQueryTimeout) {\r\n          clearTimeout(this.state.customQueryTimeout);\r\n        }\r\n        \r\n        // Update user activity to reset idle timer\r\n        this.updateUserActivity();\r\n      }\r\n    } catch (err) {\r\n      console.error(\"Neo4j query failed:\", err);\r\n      console.error(\"Query was:\", queryToExecute);\r\n      this.setState({ data: { nodes: [], links: [] } });\r\n      return;\r\n    } finally {\r\n      session.close();\r\n    }\r\n\r\n\r\n    let nodesMap = new Map();\r\n    let links = [];\r\n\r\n    // Intelligent parser\r\n    res.records.forEach((record) => {\r\n      if (record.has(\"source\") && record.has(\"target\") && record.get(\"source\") && record.get(\"target\") && \r\n          typeof record.get(\"source\") === 'string' && typeof record.get(\"target\") === 'string') {\r\n        // standard case\r\n        let source = record.get(\"source\");\r\n        let target = record.get(\"target\");\r\n\r\n        if (!nodesMap.has(source)) {\r\n          nodesMap.set(source, {\r\n            name: source,\r\n            role: record.get(\"sourceRole\"),\r\n            location: record.get(\"sourceLocation\"),\r\n            website: record.get(\"sourceWebsite\"),\r\n            x: Math.random() * 500,\r\n            y: Math.random() * 500,\r\n          });\r\n        }\r\n\r\n        if (!nodesMap.has(target)) {\r\n          nodesMap.set(target, {\r\n            name: target,\r\n            role: record.get(\"targetRole\"),\r\n            location: record.get(\"targetLocation\"),\r\n            website: record.get(\"targetWebsite\"),\r\n            x: Math.random() * 500,\r\n            y: Math.random() * 500,\r\n          });\r\n        }\r\n\r\n        if (nodesMap.has(source) && nodesMap.has(target)) {\r\n          links.push({ source, target });\r\n        } else {\r\n  console.warn(\"Invalid link skipped:\", { source, target });\r\n}\r\n      } else {\r\n        // fallback: node-only query\r\n        record.keys.forEach((key) => {\r\n          const node = record.get(key);\r\n          if (node && node.properties && node.identity) {\r\n            const name = node.properties.name || `Node-${node.identity.low}`;\r\n            if (!nodesMap.has(name)) {\r\n              nodesMap.set(name, {\r\n                name,\r\n                role: node.properties.role || \"\",\r\n                location: node.properties.location || \"\",\r\n                website: node.properties.website || \"\",\r\n                x: Math.random() * 500,\r\n                y: Math.random() * 500,\r\n              });\r\n            }\r\n          } else if (node && typeof node === 'object') {\r\n            // Handle SET query results that might have different structure\r\n            const name = node.name || node.u_name || `Node-${Date.now()}`;\r\n            if (!nodesMap.has(name)) {\r\n              nodesMap.set(name, {\r\n                name,\r\n                role: node.role || node.u_role || \"\",\r\n                location: node.location || node.u_location || \"\",\r\n                website: node.website || node.u_website || \"\",\r\n                x: Math.random() * 500,\r\n                y: Math.random() * 500,\r\n              });\r\n            }\r\n          } else if (typeof node === 'string' && key.includes('name')) {\r\n            // Handle direct string values from queries like RETURN u.name, u.role\r\n            const name = node;\r\n            if (!nodesMap.has(name)) {\r\n              nodesMap.set(name, {\r\n                name,\r\n                role: record.get(key.replace('name', 'role')) || \"\",\r\n                location: record.get(key.replace('name', 'location')) || \"\",\r\n                website: record.get(key.replace('name', 'website')) || \"\",\r\n                x: Math.random() * 500,\r\n                y: Math.random() * 500,\r\n              });\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    const nodes = Array.from(nodesMap.values());\r\n    const updatedData = { nodes, links };\r\n    \r\n    // Check if our NFC node is in the parsed results\r\n    if (this.pendingNFCNode) {\r\n      const nfcNodeInResults = nodes.find(n => n.name === this.pendingNFCNode);\r\n    }\r\n\r\n    // Calculate hash of current data for change detection\r\n    const currentDataHash = this.calculateDataHash(updatedData);\r\n    const hasChanged = this.lastDataHash !== currentDataHash;\r\n    \r\n    // Also use more detailed change detection (but not during initial load)\r\n    const hasDetailedChange = this.isInitialLoad ? false : this.hasDataChanged(updatedData, this.state.data);\r\n    \r\n    // Additional check: if the data is exactly the same, don't update\r\n    const isDataIdentical = JSON.stringify(updatedData) === JSON.stringify(this.state.data);\r\n    \r\n\r\n    \r\n\r\n\r\n    localStorage.setItem(\"graphData\", JSON.stringify(updatedData));\r\n    \r\n    // Only update state if there's a change or if it's the initial load\r\n    const now = Date.now();\r\n    const timeSinceLastUpdate = now - this.lastUpdateTime;\r\n    \r\n    // Force update if we have a newNodeName (NFC operation) regardless of debounce\r\n    const forceUpdateForNFC = newNodeName && this.pendingNFCNode && newNodeName === this.pendingNFCNode;\r\n    \r\n    if ((hasChanged || hasDetailedChange || this.lastDataHash === null || forceUpdateForNFC) && \r\n        !isDataIdentical &&\r\n        (timeSinceLastUpdate > this.updateDebounceTime || this.lastDataHash === null || forceUpdateForNFC) &&\r\n        this.updateCount < this.maxUpdatesPerCycle) {\r\n      // Update the hash only when we actually update the state\r\n      this.lastDataHash = currentDataHash;\r\n      this.lastUpdateTime = now;\r\n      this.updateCount++;\r\n      \r\n      // Mark initial load as complete after first successful update\r\n      if (this.isInitialLoad) {\r\n        this.isInitialLoad = false;\r\n      }\r\n      \r\n      // Preserve latestNode if newNodeName is null but we have a valid latestNode\r\n      // Don't set latestNode during initial load\r\n      const nodeToSet = this.isInitialLoad ? null : (newNodeName || this.state.latestNode);\r\n      \r\n      // Note: Focus timeout is now managed in GraphView component\r\n      \r\n      this.setState({ \r\n        data: updatedData, \r\n        latestNode: nodeToSet,\r\n        lastUpdateTime: hasChanged ? now : this.state.lastUpdateTime\r\n      }, () => {\r\n      if (newNodeName) {\r\n        // Focus on the new node with multiple attempts to ensure it works (NFC editing)\r\n        this.focusOnNewNode(newNodeName, updatedData);\r\n      } else if (this.changedNodesFromPolling.length > 0 && !this.isInitialLoad) {\r\n        // Focus on the first changed node from polling (but not on initial load) - non-editable\r\n        const firstChangedNode = this.changedNodesFromPolling[0];\r\n        this.focusOnPollingNode(firstChangedNode, updatedData);\r\n        \r\n        // Set a 10-second timeout to clear the focus\r\n        if (this.pollingFocusTimeout) {\r\n          clearTimeout(this.pollingFocusTimeout);\r\n        }\r\n        this.pollingFocusTimeout = setTimeout(() => {\r\n          this.setState({ pollingFocusNode: null });\r\n          this.pollingFocusTimeout = null;\r\n        }, 10000); // 10 seconds\r\n        \r\n        // Clear the changed nodes list after focusing\r\n        this.changedNodesFromPolling = [];\r\n      }\r\n    });\r\n    } else {\r\n      // Even if no change, we might need to update latestNode for new additions\r\n      if (newNodeName && this.state.latestNode !== newNodeName) {\r\n        this.setState({ latestNode: newNodeName });\r\n      }\r\n      // Reset update count when no changes are detected\r\n      this.updateCount = 0;\r\n    }\r\n  };\r\n\r\n    // Focus on a newly added node with temporary focus (1 second) then return to user control\r\n  focusOnNewNode = (nodeName, graphData) => {\r\n    \r\n    const attemptFocus = (attempt = 1) => {\r\n      if (attempt > 5) {\r\n        return;\r\n      }\r\n\r\n      const newNode = graphData.nodes.find((n) => n.name === nodeName);\r\n      if (!newNode) {\r\n        setTimeout(() => attemptFocus(attempt + 1), 500);\r\n        return;\r\n      }\r\n\r\n      if (!this.fgRef.current) {\r\n        setTimeout(() => attemptFocus(attempt + 1), 500);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        // Focus on the node\r\n        this.fgRef.current.centerAt(newNode.x, newNode.y, 1500);\r\n        this.fgRef.current.zoom(1.25);\r\n        \r\n        // Set the latestNode state for visual highlighting\r\n        this.setState({ latestNode: nodeName });\r\n        \r\n        // Note: Focus timeout is now managed in GraphView component\r\n        // The auto-zoom will handle the temporary focus behavior\r\n        \r\n      } catch (error) {\r\n        setTimeout(() => attemptFocus(attempt + 1), 500);\r\n      }\r\n    };\r\n\r\n    // Start with a longer delay for the first attempt to ensure graph is rendered\r\n    setTimeout(() => attemptFocus(1), 1000);\r\n  };\r\n\r\n  // Focus on polling changes (non-editable - sets pollingFocusNode)\r\n  focusOnPollingNode = (nodeName, graphData) => {\r\n    \r\n    const attemptFocus = (attempt = 1) => {\r\n      if (attempt > 5) {\r\n        return;\r\n      }\r\n\r\n      const newNode = graphData.nodes.find((n) => n.name === nodeName);\r\n      if (!newNode) {\r\n        setTimeout(() => attemptFocus(attempt + 1), 500);\r\n        return;\r\n      }\r\n\r\n      if (!this.fgRef.current) {\r\n        setTimeout(() => attemptFocus(attempt + 1), 500);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        this.fgRef.current.centerAt(newNode.x, newNode.y, 1500);\r\n        this.fgRef.current.zoom(1.25);\r\n        \r\n        // Set pollingFocusNode (non-editable)\r\n        this.setState({ pollingFocusNode: nodeName });\r\n      } catch (error) {\r\n        setTimeout(() => attemptFocus(attempt + 1), 500);\r\n      }\r\n    };\r\n\r\n    // Start with a longer delay for the first attempt to ensure graph is rendered\r\n    setTimeout(() => attemptFocus(1), 1000);\r\n  };\r\n\r\n  // Focus on multiple nodes (for future use)\r\n  focusOnMultipleNodes = (nodeNames, graphData) => {\r\n    if (!nodeNames || nodeNames.length === 0) return;\r\n    \r\n    // For now, focus on the first node\r\n    // In the future, this could calculate a bounding box of all nodes\r\n    this.focusOnNewNode(nodeNames[0], graphData);\r\n  };\r\n\r\n  // Calculate a simple hash of the graph data for change detection\r\n  calculateDataHash = (data) => {\r\n    // Only hash the actual data, not the random coordinates\r\n    const nodesStr = data.nodes.map(n => `${n.name}:${n.role}:${n.location}:${n.website}`).sort().join('|');\r\n    const linksStr = data.links.map(l => {\r\n      const source = typeof l.source === 'object' ? l.source.name : l.source;\r\n      const target = typeof l.target === 'object' ? l.target.name : l.target;\r\n      return `${source}:${target}`;\r\n    }).sort().join('|');\r\n    return `${nodesStr}|${linksStr}`;\r\n  };\r\n\r\n  // More detailed change detection with change tracking\r\n  hasDataChanged = (newData, oldData) => {\r\n    if (!oldData || !oldData.nodes || !oldData.links) return true;\r\n    \r\n    let changedNodes = [];\r\n    let hasChanges = false;\r\n    \r\n    // Check if number of nodes or links changed\r\n    if (newData.nodes.length !== oldData.nodes.length || \r\n        newData.links.length !== oldData.links.length) {\r\n      hasChanges = true;\r\n    }\r\n    \r\n    // Check if any node properties changed\r\n    const oldNodesMap = new Map(oldData.nodes.map(n => [n.name, n]));\r\n    for (const newNode of newData.nodes) {\r\n      const oldNode = oldNodesMap.get(newNode.name);\r\n      if (!oldNode) {\r\n        // New node added\r\n        changedNodes.push(newNode.name);\r\n        hasChanges = true;\r\n      } else if (oldNode.role !== newNode.role || \r\n                 oldNode.location !== newNode.location || \r\n                 oldNode.website !== newNode.website) {\r\n        // Existing node modified\r\n        changedNodes.push(newNode.name);\r\n        hasChanges = true;\r\n      }\r\n    }\r\n    \r\n    // Check if any links changed\r\n    const oldLinksSet = new Set(oldData.links.map(l => {\r\n      const source = typeof l.source === 'object' ? l.source.name : l.source;\r\n      const target = typeof l.target === 'object' ? l.target.name : l.target;\r\n      return `${source}:${target}`;\r\n    }));\r\n    \r\n    for (const newLink of newData.links) {\r\n      const source = typeof newLink.source === 'object' ? newLink.source.name : newLink.source;\r\n      const target = typeof newLink.target === 'object' ? newLink.target.name : newLink.target;\r\n      if (!oldLinksSet.has(`${source}:${target}`)) {\r\n        // New link added - focus on both source and target nodes\r\n        if (!changedNodes.includes(source)) changedNodes.push(source);\r\n        if (!changedNodes.includes(target)) changedNodes.push(target);\r\n        hasChanges = true;\r\n      }\r\n    }\r\n    \r\n    // Store changed nodes for focusing\r\n    if (hasChanges && changedNodes.length > 0) {\r\n      this.changedNodesFromPolling = changedNodes;\r\n    }\r\n    \r\n    return hasChanges;\r\n  };\r\n\r\n  // Start polling for changes\r\n  startPolling = () => {\r\n    if (this.pollingInterval) {\r\n      clearInterval(this.pollingInterval);\r\n    }\r\n    \r\n    this.setState({ isPolling: true });\r\n    this.pollingInterval = setInterval(() => {\r\n      // Only poll if the tab is active (to save resources)\r\n      if (!document.hidden) {\r\n        // Use default query for polling, but respect custom query state, mutation processing, and NFC operations\r\n        if (this.state.customQueryActive || this.state.processingMutation || this.isNFCOperation) {\r\n          return;\r\n        }\r\n        // Don't preserve latestNode during polling - let change detection determine focus\r\n        this.loadData(null, this.defaultQuery);\r\n      }\r\n    }, 5000); // Check every 5 seconds\r\n    \r\n    // Reset update count every 30 seconds to prevent permanent blocking\r\n    if (this.updateCountResetInterval) {\r\n      clearInterval(this.updateCountResetInterval);\r\n    }\r\n    this.updateCountResetInterval = setInterval(() => {\r\n      this.updateCount = 0;\r\n    }, 30000);\r\n  };\r\n\r\n  // Stop polling\r\n  stopPolling = () => {\r\n    if (this.pollingInterval) {\r\n      clearInterval(this.pollingInterval);\r\n      this.pollingInterval = null;\r\n    }\r\n    if (this.updateCountResetInterval) {\r\n      clearInterval(this.updateCountResetInterval);\r\n      this.updateCountResetInterval = null;\r\n    }\r\n    this.setState({ isPolling: false });\r\n  };\r\n\r\n  // WebSocket methods for real-time updates (disabled for now)\r\n  connectWebSocket = () => {\r\n    // WebSocket is disabled - using polling instead\r\n    // Uncomment and configure when WebSocket server is available\r\n    /*\r\n    try {\r\n      this.websocket = new WebSocket('wss://your-websocket-server.com');\r\n      \r\n      this.websocket.onopen = () => {\r\n        this.setState({ wsConnected: true, useWebSocket: true });\r\n      };\r\n      \r\n      this.websocket.onmessage = (event) => {\r\n        const message = JSON.parse(event.data);\r\n        if (message.type === 'graph_update') {\r\n          this.loadData(null, this.defaultQuery);\r\n        }\r\n      };\r\n      \r\n      this.websocket.onclose = () => {\r\n        this.setState({ wsConnected: false });\r\n        setTimeout(() => {\r\n          if (!this.state.isPolling) {\r\n            this.startPolling();\r\n          }\r\n        }, 5000);\r\n      };\r\n      \r\n      this.websocket.onerror = (error) => {\r\n        this.setState({ wsConnected: false });\r\n      };\r\n    } catch (error) {\r\n      this.startPolling();\r\n    }\r\n    */\r\n    \r\n    // Start polling directly since WebSocket is disabled\r\n    this.startPolling();\r\n  };\r\n\r\n  disconnectWebSocket = () => {\r\n    if (this.websocket) {\r\n      this.websocket.close();\r\n      this.websocket = null;\r\n    }\r\n    this.setState({ wsConnected: false, useWebSocket: false });\r\n  };\r\n\r\n  // Enhanced componentDidMount to start polling directly\r\n  componentDidMount() {\r\n    // Validate and clean the query state first\r\n    this.validateAndCleanQuery();\r\n    \r\n    // Run timestamp migration for existing data\r\n    migrateTimestamps(this.driver);\r\n    \r\n    this.loadData();\r\n    \r\n    // Start polling (WebSocket is disabled)\r\n    this.connectWebSocket();\r\n    \r\n    // Add visibility change listener to pause polling when tab is not active\r\n    this.handleVisibilityChange = () => {\r\n      // Tab visibility change handling\r\n    };\r\n    \r\n    document.addEventListener('visibilitychange', this.handleVisibilityChange);\r\n    \r\n    // Start idle detection\r\n    this.startIdleDetection();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    // Clean up both polling and WebSocket\r\n    this.stopPolling();\r\n    this.disconnectWebSocket();\r\n    \r\n    // Clear custom query timeout\r\n    if (this.state.customQueryTimeout) {\r\n      clearTimeout(this.state.customQueryTimeout);\r\n    }\r\n    \r\n    // Clear mutation reload timeout\r\n    if (this.mutationReloadTimeout) {\r\n      clearTimeout(this.mutationReloadTimeout);\r\n      this.mutationReloadTimeout = null;\r\n    }\r\n    \r\n    // Clear processing mutation state\r\n    this.setState({ processingMutation: false });\r\n    \r\n    // Clear polling focus timeout\r\n    if (this.pollingFocusTimeout) {\r\n      clearTimeout(this.pollingFocusTimeout);\r\n      this.pollingFocusTimeout = null;\r\n    }\r\n    \r\n    // Note: Focus timeout is now managed in GraphView component\r\n    \r\n    // Stop breathing animation\r\n    this.stopBreathingAnimation();\r\n    \r\n    // Stop idle detection\r\n    this.stopIdleDetection();\r\n    \r\n    // Remove visibility change listener\r\n    if (this.handleVisibilityChange) {\r\n      document.removeEventListener('visibilitychange', this.handleVisibilityChange);\r\n    }\r\n  }\r\n\r\n  addNodeNFC = async (newUser, nfcUserName) => {\r\n    // Helper function to capitalize first letter of each word\r\n    const capitalizeWords = (str) => {\r\n      if (!str) return str;\r\n      return str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\r\n    };\r\n\r\n    const capitalizedNewUser = capitalizeWords(newUser);\r\n    const capitalizedNfcUser = capitalizeWords(nfcUserName);\r\n\r\n    // Set NFC operation flag to prevent double reload\r\n    this.isNFCOperation = true;\r\n\r\n    // Clear any existing pending NFC node to prevent conflicts\r\n    if (this.pendingNFCNode) {\r\n      this.pendingNFCNode = null;\r\n    }\r\n\r\n    let session = this.driver.session({ database: \"neo4j\" });\r\n    try {\r\n      // Create a single timestamp for the entire operation\r\n      const timestamp = Date.now();\r\n      \r\n      // First, check if a node with the same name as the new user already exists\r\n      const checkExistingUser = await session.run(\r\n        `MATCH (u:User {name: $user}) RETURN u.name as name`,\r\n        { user: capitalizedNewUser }\r\n      );\r\n\r\n      let nodeToFocus = capitalizedNewUser;\r\n      let isExistingNode = false;\r\n\r\n      if (checkExistingUser.records.length > 0) {\r\n        // Node with this name already exists, use the existing node\r\n        console.log(`Node with name \"${capitalizedNewUser}\" already exists, using existing node`);\r\n        isExistingNode = true;\r\n        nodeToFocus = capitalizedNewUser;\r\n      } else {\r\n        // Node doesn't exist, create a new one\r\n        console.log(`Creating new node with name \"${capitalizedNewUser}\"`);\r\n      }\r\n\r\n      // Only run duplicate cleanup for new nodes, not for existing nodes being merged\r\n      if (!this.isNFCOperation || !this.pendingNFCNode) {\r\n        // First, check if there are multiple nodes with the same name and merge them\r\n        const duplicateCheck = await session.run(\r\n          `MATCH (u:User {name: $user})\r\n           RETURN count(u) as count`,\r\n          { user: capitalizedNewUser }\r\n        );\r\n        \r\n        const duplicateCount = duplicateCheck.records[0].get('count').toNumber();\r\n        \r\n        if (duplicateCount > 1) {\r\n          console.log(`Found ${duplicateCount} duplicate nodes for \"${capitalizedNewUser}\", merging them...`);\r\n          \r\n          // Get all nodes with this name and their properties\r\n          const allNodes = await session.run(\r\n            `MATCH (u:User {name: $user})\r\n             RETURN u.role as role, u.location as location, u.website as website\r\n             ORDER BY u.role DESC, u.location DESC, u.website DESC`,\r\n            { user: capitalizedNewUser }\r\n          );\r\n          \r\n          // Find the best properties (non-empty values)\r\n          let bestRole = '';\r\n          let bestLocation = '';\r\n          let bestWebsite = '';\r\n          \r\n          allNodes.records.forEach(record => {\r\n            const role = record.get('role');\r\n            const location = record.get('location');\r\n            const website = record.get('website');\r\n            \r\n            if (role && role !== '') bestRole = role;\r\n            if (location && location !== '') bestLocation = location;\r\n            if (website && website !== '') bestWebsite = website;\r\n          });\r\n          \r\n          // Delete all nodes with this name and recreate with best properties\r\n          await session.run(\r\n            `MATCH (u:User {name: $user})\r\n             DETACH DELETE u`,\r\n            { user: capitalizedNewUser }\r\n          );\r\n          \r\n          // Create a single node with the best properties\r\n          await session.run(\r\n            `CREATE (u:User {name: $user, role: $role, location: $location, website: $website, createdAt: $createdAt})`,\r\n            { \r\n              user: capitalizedNewUser,\r\n              role: bestRole,\r\n              location: bestLocation,\r\n              website: bestWebsite,\r\n              createdAt: timestamp\r\n            }\r\n          );\r\n          \r\n          console.log(`Merged duplicate nodes for \"${capitalizedNewUser}\" with properties:`, { bestRole, bestLocation, bestWebsite, timestamp });\r\n        }\r\n      }\r\n\r\n      // Create or connect the nodes\r\n      // Use the same timestamp for consistency across all operations\r\n      await session.run(\r\n        `MERGE (u:User {name: $user}) \r\n         ON CREATE SET u.role = '', \r\n                       u.location = '', \r\n                       u.website = '',\r\n                       u.createdAt = $timestamp\r\n\r\n         MERGE (nfc:User {name: $nfcUser}) \r\n         ON CREATE SET nfc.role = '', \r\n                       nfc.location = '', \r\n                       nfc.website = '',\r\n                       nfc.createdAt = $timestamp\r\n\r\n         MERGE (u)-[r:CONNECTED_TO]->(nfc) \r\n         ON CREATE SET r.createdAt = $timestamp\r\n        `,\r\n        { \r\n          user: capitalizedNewUser, \r\n          nfcUser: capitalizedNfcUser,\r\n          timestamp: timestamp\r\n        }\r\n        );\r\n      \r\n      console.log(`Created/connected nodes with timestamp: ${timestamp} for ${capitalizedNewUser} -> ${capitalizedNfcUser}`);\r\n      \r\n      // Store the node name for focusing after mutation completes\r\n      this.pendingNFCNode = nodeToFocus;\r\n      \r\n      // Trigger a single loadData call to reload the graph with the node\r\n      await this.loadData(nodeToFocus, this.defaultQuery);\r\n      \r\n      // Wait for the state to be updated, then focus and auto-popup form\r\n      let checkCount = 0;\r\n      const waitForStateUpdate = () => {\r\n        const nodeExists = this.state.data.nodes.find(n => n.name === nodeToFocus);\r\n        checkCount++;\r\n        \r\n        if (nodeExists) {\r\n          this.focusOnNewNode(nodeToFocus, this.state.data);\r\n          this.pendingNFCNode = null;\r\n          this.isNFCOperation = false;\r\n          \r\n          // Refresh timeline stats if in timeline mode\r\n          this.refreshTimelineStats();\r\n          \r\n          // Auto-popup the form for the NFC node (whether new or existing)\r\n          this.setState({ \r\n            nfcNodeForAutoPopup: nodeToFocus \r\n          });\r\n        } else if (checkCount < 10) { // Limit retries to prevent infinite loops\r\n          setTimeout(waitForStateUpdate, 500);\r\n        } else {\r\n          console.error(\"Failed to find node in state after multiple attempts\");\r\n          this.pendingNFCNode = null;\r\n          this.isNFCOperation = false;\r\n        }\r\n      };\r\n      \r\n      // Start checking for state update after a short delay\r\n      setTimeout(waitForStateUpdate, 1000);\r\n      \r\n    } catch (error) {\r\n      console.error(\"Error adding user:\", error);\r\n      this.pendingNFCNode = null;\r\n      this.isNFCOperation = false;\r\n    } finally {\r\n      session.close();\r\n    }\r\n  };\r\n\r\n  handleChange = (event) => {\r\n    // Only update the query state if it's a valid Cypher query or empty\r\n    const newQuery = event.target.value;\r\n    \r\n    // Allow empty queries (for clearing)\r\n    if (!newQuery || newQuery.trim() === '') {\r\n      this.setState({ query: this.defaultQuery });\r\n      return;\r\n    }\r\n    \r\n    // Check if it starts with valid Cypher keywords\r\n    const validStartKeywords = ['MATCH', 'CREATE', 'MERGE', 'DELETE', 'SET', 'RETURN', 'WITH', 'UNWIND', 'CALL'];\r\n    const queryStart = newQuery.trim().toUpperCase();\r\n    const isValidQuery = validStartKeywords.some(keyword => queryStart.startsWith(keyword));\r\n    \r\n    if (isValidQuery) {\r\n      this.setState({ query: newQuery });\r\n    }\r\n  };\r\n\r\n  // Method to reset query to default\r\n  resetQuery = () => {\r\n    this.setState({ \r\n      query: this.defaultQuery,\r\n      customQueryActive: false,\r\n      customQueryTimeout: null,\r\n      processingMutation: false\r\n    });\r\n    \r\n    // Clear any existing timeout\r\n    if (this.state.customQueryTimeout) {\r\n      clearTimeout(this.state.customQueryTimeout);\r\n    }\r\n  };\r\n\r\n  // Method to validate and clean the current query state\r\n  validateAndCleanQuery = () => {\r\n    const currentQuery = this.state.query;\r\n    \r\n    // Check if current query is valid\r\n    if (!currentQuery || typeof currentQuery !== 'string' || currentQuery.trim() === '') {\r\n      this.setState({ query: this.defaultQuery });\r\n      return;\r\n    }\r\n    \r\n    // Check if it starts with valid Cypher keywords\r\n    const validStartKeywords = ['MATCH', 'CREATE', 'MERGE', 'DELETE', 'SET', 'RETURN', 'WITH', 'UNWIND', 'CALL'];\r\n    const queryStart = currentQuery.trim().toUpperCase();\r\n    const isValidQuery = validStartKeywords.some(keyword => queryStart.startsWith(keyword));\r\n    \r\n    if (!isValidQuery) {\r\n      this.setState({ query: this.defaultQuery });\r\n    }\r\n  };\r\n\r\n  // Callback to clear NFC popup trigger\r\n  onNfcPopupTriggered = () => {\r\n    this.setState({ nfcNodeForAutoPopup: null });\r\n  };\r\n\r\n  // Timeline methods\r\n  toggleTimelineMode = async () => {\r\n    if (!this.state.timelineMode) {\r\n      // Entering timeline mode - get timeline stats\r\n      const stats = await this.getTimelineStats();\r\n      \r\n      // Stop breathing animation when entering timeline mode\r\n      this.stopBreathingAnimation();\r\n      \r\n      // Ensure we have valid stats\r\n      const validStats = stats || {\r\n        earliest: new Date(Date.now() - 86400000), // 24 hours ago\r\n        latest: new Date()\r\n      };\r\n      \r\n      this.setState(prevState => ({\r\n        timelineMode: true,\r\n        timelineDate: validStats.latest,\r\n        timelineData: prevState.data,\r\n        timelineStats: validStats\r\n      }));\r\n    } else {\r\n      // Exiting timeline mode\r\n      this.setState({\r\n        timelineMode: false,\r\n        timelineDate: null,\r\n        timelineData: null,\r\n        timelineStats: null\r\n      });\r\n      \r\n      // Restart breathing animation if user is idle\r\n      if (!this.state.isUserActive) {\r\n        this.startBreathingAnimation();\r\n      }\r\n    }\r\n  };\r\n\r\n  loadTimelineData = async (date) => {\r\n    if (!this.driver) return;\r\n\r\n    const session = this.driver.session();\r\n    try {\r\n      const timestamp = date.getTime();\r\n      \r\n\r\n      \r\n      // Query for nodes and relationships that existed at the given timestamp\r\n      const result = await session.run(\r\n        `MATCH (u:User)\r\n         WHERE u.createdAt IS NOT NULL AND u.createdAt <= $timestamp\r\n         OPTIONAL MATCH (u)-[r:CONNECTED_TO]->(v:User)\r\n         WHERE v.createdAt IS NOT NULL AND v.createdAt <= $timestamp\r\n         AND r.createdAt IS NOT NULL AND r.createdAt <= $timestamp\r\n         RETURN u.name AS source, u.role AS sourceRole, u.location AS sourceLocation, u.website AS sourceWebsite,\r\n                v.name AS target, v.role AS targetRole, v.location AS targetLocation, v.website AS targetWebsite`,\r\n        { timestamp }\r\n      );\r\n\r\n      const nodes = new Set();\r\n      const links = [];\r\n\r\n      result.records.forEach(record => {\r\n        const source = record.get('source');\r\n        const target = record.get('target');\r\n        const sourceRole = record.get('sourceRole');\r\n        const targetRole = record.get('targetRole');\r\n        const sourceLocation = record.get('sourceLocation');\r\n        const targetLocation = record.get('targetLocation');\r\n        const sourceWebsite = record.get('sourceWebsite');\r\n        const targetWebsite = record.get('targetWebsite');\r\n\r\n        // Always add the source node\r\n        nodes.add(source);\r\n        \r\n        // Add target node and link only if there's a relationship\r\n        if (target) {\r\n          nodes.add(target);\r\n          links.push({\r\n            source,\r\n            target,\r\n            sourceRole,\r\n            targetRole,\r\n            sourceLocation,\r\n            targetLocation,\r\n            sourceWebsite,\r\n            targetWebsite\r\n          });\r\n        }\r\n      });\r\n\r\n      const timelineData = {\r\n        nodes: Array.from(nodes).map(name => ({ name })),\r\n        links\r\n      };\r\n\r\n\r\n\r\n      this.setState({\r\n        timelineData,\r\n        timelineDate: date\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Error loading timeline data:', error);\r\n    } finally {\r\n      session.close();\r\n    }\r\n  };\r\n\r\n  updateTimelineDate = (date) => {\r\n    this.loadTimelineData(date);\r\n  };\r\n\r\n  getTimelineStats = async () => {\r\n    if (!this.driver) return null;\r\n\r\n    const session = this.driver.session();\r\n    try {\r\n      // Get the earliest and latest timestamps, prioritizing relationships for start time\r\n      const result = await session.run(\r\n        `MATCH ()-[r:CONNECTED_TO]->()\r\n         WHERE r.createdAt IS NOT NULL\r\n         RETURN min(r.createdAt) as earliest, max(r.createdAt) as latest`\r\n      );\r\n\r\n      if (result.records.length > 0) {\r\n        const record = result.records[0];\r\n        const earliest = record.get('earliest');\r\n        const latest = record.get('latest');\r\n        \r\n\r\n        \r\n        // Helper function to validate and convert timestamp\r\n        const convertTimestamp = (timestamp) => {\r\n          if (!timestamp) return null;\r\n          \r\n          // Convert to number if it's a string\r\n          let numTimestamp = Number(timestamp);\r\n          \r\n          // Check if it's a valid timestamp (between 1970 and 2100)\r\n          const minValid = new Date('1970-01-01').getTime();\r\n          const maxValid = new Date('2100-01-01').getTime();\r\n          \r\n          // Try as milliseconds first\r\n          if (numTimestamp >= minValid && numTimestamp <= maxValid) {\r\n            return new Date(numTimestamp);\r\n          }\r\n          \r\n          // Try as seconds (multiply by 1000)\r\n          const secondsTimestamp = numTimestamp * 1000;\r\n          if (secondsTimestamp >= minValid && secondsTimestamp <= maxValid) {\r\n            return new Date(secondsTimestamp);\r\n          }\r\n          \r\n          // If it's not a valid timestamp, return null\r\n          return null;\r\n        };\r\n        \r\n        const earliestDate = convertTimestamp(earliest);\r\n        const latestDate = convertTimestamp(latest);\r\n        \r\n        const stats = {\r\n          earliest: earliestDate || new Date(Date.now() - 86400000), // Default to 24 hours ago\r\n          latest: latestDate || new Date()\r\n        };\r\n        \r\n        return stats;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting timeline stats:', error);\r\n    } finally {\r\n      session.close();\r\n    }\r\n    return null;\r\n  };\r\n\r\n  resetToCurrentTime = () => {\r\n    this.setState({\r\n      timelineMode: false,\r\n      timelineDate: null,\r\n      timelineData: null\r\n    });\r\n  };\r\n\r\n  // Refresh timeline stats when new nodes are added\r\n  refreshTimelineStats = async () => {\r\n    if (this.state.timelineMode) {\r\n      const stats = await this.getTimelineStats();\r\n      \r\n      // Ensure timeline date stays within valid range\r\n      let newTimelineDate = this.state.timelineDate;\r\n      if (stats && this.state.timelineDate) {\r\n        if (this.state.timelineDate.getTime() > stats.latest.getTime()) {\r\n          newTimelineDate = stats.latest;\r\n        } else if (this.state.timelineDate.getTime() < stats.earliest.getTime()) {\r\n          newTimelineDate = stats.earliest;\r\n        }\r\n      }\r\n      \r\n      this.setState({ \r\n        timelineStats: stats,\r\n        timelineDate: newTimelineDate\r\n      });\r\n      \r\n      // Reload timeline data if date changed\r\n      if (newTimelineDate && newTimelineDate.getTime() !== this.state.timelineDate?.getTime()) {\r\n        this.loadTimelineData(newTimelineDate);\r\n      }\r\n    }\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <Router>\r\n      <div>\r\n      <Routes>\r\n      <Route path=\"/:username\" element={<NFCTrigger addNode={this.addNodeNFC} />} />\r\n      <Route path=\"/\" element={\r\n        <GraphView \r\n        data={this.state.data} \r\n        handleChange={this.handleChange} \r\n        loadData={this.loadData} \r\n        fgRef={this.fgRef} \r\n        latestNode={this.state.latestNode} \r\n        pollingFocusNode={this.state.pollingFocusNode}\r\n    driver={this.driver} // Pass the driver\r\n        processingMutation={this.state.processingMutation}\r\n        updateUserActivity={this.updateUserActivity}\r\n        isUserActive={this.state.isUserActive}\r\n        scaleTransitionStart={this.scaleTransitionStart}\r\n        scaleTransitionDuration={this.scaleTransitionDuration}\r\n        nfcNodeForAutoPopup={this.state.nfcNodeForAutoPopup}\r\n        onNfcPopupTriggered={this.onNfcPopupTriggered}\r\n        timelineMode={this.state.timelineMode}\r\n        timelineDate={this.state.timelineDate}\r\n        timelineData={this.state.timelineData}\r\n        timelineStats={this.state.timelineStats}\r\n        toggleTimelineMode={this.toggleTimelineMode}\r\n        loadTimelineData={this.loadTimelineData}\r\n        updateTimelineDate={this.updateTimelineDate}\r\n        resetToCurrentTime={this.resetToCurrentTime}\r\n    />\r\n  } />\r\n  </Routes>\r\n  \r\n\r\n  </div>\r\n  </Router>\r\n  );\r\n}\r\n}\r\n\r\nconst NFCTrigger = ({ addNode }) => {\r\n  const location = useLocation();\r\n  const { username } = useParams();\r\n\r\n  React.useEffect(() => {\r\n    const addAndRedirect = async () => {\r\n      // Generate a unique identifier for the person tapping the NFC tag\r\n      // This could be based on device info, session, or a random ID\r\n      const newUser = `User-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n      console.log(`NFC Trigger: Starting NFC operation for ${username} with visitor ${newUser}`);\r\n\r\n      try {\r\n        await addNode(newUser, username); // newUser = visitor, username = NFC tag owner\r\n        console.log(`NFC Trigger: addNode completed successfully`);\r\n        } catch (error) {\r\n          console.error(\"NFC Trigger: Error adding user:\", error);\r\n          return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n          window.location.assign(\"/MITNet/#/\");\r\n          }, 2000);\r\n        };\r\n\r\n        addAndRedirect();\r\n        }, [location, username]);\r\n\r\n        return <div style={{ textAlign: \"center\", padding: \"20px\", fontSize: \"16px\", color: \"red\" }}>Adding you to {username}'s network...</div>\r\n      };\r\n\r\n              const GraphView = ({ data, handleChange, loadData, fgRef, latestNode, pollingFocusNode, driver, processingMutation, updateUserActivity, isUserActive, scaleTransitionStart, scaleTransitionDuration, nfcNodeForAutoPopup, onNfcPopupTriggered, timelineMode, timelineDate, timelineData, timelineStats, toggleTimelineMode, loadTimelineData, updateTimelineDate, resetToCurrentTime }) => {\r\n        const [inputValue, setInputValue] = useState(\"\"); \r\n        const [selectedNode, setSelectedNode] = useState(null);\r\n        const [editedNode, setEditedNode] = useState(null);\r\n        const [focusNode, setFocusNode] = useState(null);\r\n        const [clickedNode, setClickedNode] = useState(null);\r\n        const [lastAction, setLastAction] = useState(null); // 'search', 'click', 'latestNode', or 'mutation'\r\n        const [mutatedNodes, setMutatedNodes] = useState([]); // Track nodes created/modified by mutation queries\r\n        const [analyticalAnswer, setAnalyticalAnswer] = useState(null); // For displaying analytical answers\r\n        const [showAnalyticalModal, setShowAnalyticalModal] = useState(false); // For showing/hiding the answer modal\r\n        const [relationshipNote, setRelationshipNote] = useState(\"\"); // For relationship notes when connecting to existing nodes\r\n        const [nfcNameInput, setNfcNameInput] = useState(\"\");\r\n        const [nfcRoleInput, setNfcRoleInput] = useState(\"\"); // For initial NFC name input\r\n        const [showNfcNamePopup, setShowNfcNamePopup] = useState(false); // For showing NFC name input popup\r\n        const [showProfilePopup, setShowProfilePopup] = useState(false); // For showing profile completion popup\r\n        const [pendingNfcName, setPendingNfcName] = useState(\"\"); // Store the name that was entered\r\n        const [selectedLink, setSelectedLink] = useState(null); // For selected relationship/link\r\n        const [relationshipData, setRelationshipData] = useState({}); // Store relationship data\r\n        const [showNfcRelationshipPopup, setShowNfcRelationshipPopup] = useState(false);\r\n        const [currentNfcConnection, setCurrentNfcConnection] = useState(null); // For NFC relationship note popup\r\n        const [hoveredLink, setHoveredLink] = useState(null); // For link hover effects\r\n        const [focusTimeout, setFocusTimeout] = useState(null); // Track focus timeout\r\n        const [autoZoomTriggered, setAutoZoomTriggered] = useState(false); // Track if auto-zoom has been triggered\r\n\r\n        // Detect when latestNode changes (NFC addition) and set lastAction\r\n        useEffect(() => {\r\n          if (latestNode) {\r\n            setLastAction('latestNode');\r\n            // Clear any existing focus timeouts when new visual states are set\r\n            if (focusTimeout) {\r\n              clearTimeout(focusTimeout);\r\n              setFocusTimeout(null);\r\n            }\r\n            setAutoZoomTriggered(false); // Allow new auto-zoom for this latestNode\r\n          }\r\n        }, [latestNode, focusTimeout]);\r\n\r\n        // Auto-popup form for NFC nodes\r\n        useEffect(() => {\r\n          if (nfcNodeForAutoPopup && data.nodes.length > 0) {\r\n            // Find the NFC node in the data\r\n            const nfcNode = data.nodes.find(node => node.name === nfcNodeForAutoPopup);\r\n            if (nfcNode) {\r\n              // Show the initial name input popup for NFC nodes\r\n              setShowNfcNamePopup(true);\r\n              setNfcNameInput(\"\");\r\n              setFocusNode(nfcNode.name);\r\n              setClickedNode(nfcNode.name);\r\n              setLastAction('latestNode');\r\n              \r\n              // Clear the nfcNodeForAutoPopup after triggering the popup\r\n              if (typeof onNfcPopupTriggered === 'function') {\r\n                onNfcPopupTriggered();\r\n              }\r\n            }\r\n          }\r\n        }, [nfcNodeForAutoPopup, data.nodes]);\r\n\r\n        // Initial zoom when graph first loads\r\n        useEffect(() => {\r\n          if (fgRef.current && data.nodes.length > 0 && !lastAction) {\r\n            // Wait a bit for the graph to settle, then zoom to 2x\r\n            setTimeout(() => {\r\n              if (fgRef.current) {\r\n                fgRef.current.zoom(2, 1000);\r\n              }\r\n            }, 1000);\r\n          }\r\n        }, [data.nodes, fgRef, lastAction]);\r\n\r\n        // Compute 1-degree neighbors of latestNode\r\n        const getOneDegreeNodes = () => {\r\n          if (!latestNode || !data) return new Set();\r\n          const neighbors = new Set();\r\n          neighbors.add(latestNode);\r\n          data.links.forEach(link => {\r\n            if (link.source === latestNode) neighbors.add(link.target);\r\n            if (link.target === latestNode) neighbors.add(link.source);\r\n          });\r\n          return neighbors;\r\n        };\r\n        const oneDegreeNodes = getOneDegreeNodes();\r\n\r\n        // Compute N-degree neighbors of latestNode\r\n        const visibleDegree = 1; // Change this value to adjust visible degree\r\n        const getNDegreeNodes = (startNode, degree) => {\r\n          if (!startNode || !data) return new Set();\r\n          const visited = new Set();\r\n          let currentLevel = new Set([startNode]);\r\n          for (let d = 0; d < degree; d++) {\r\n            const nextLevel = new Set();\r\n            data.links.forEach(link => {\r\n              // Normalize source/target to node names if they are objects\r\n              const sourceName = typeof link.source === 'object' ? link.source.name : link.source;\r\n              const targetName = typeof link.target === 'object' ? link.target.name : link.target;\r\n              currentLevel.forEach(n => {\r\n                if (n === sourceName && !visited.has(targetName)) {\r\n                  nextLevel.add(targetName);\r\n                }\r\n                if (n === targetName && !visited.has(sourceName)) {\r\n                  nextLevel.add(sourceName);\r\n                }\r\n              });\r\n            });\r\n            nextLevel.forEach(n => visited.add(n));\r\n            currentLevel.forEach(n => visited.add(n));\r\n            currentLevel = nextLevel;\r\n          }\r\n          visited.add(startNode);\r\n          return visited;\r\n        };\r\n        // For visibility: use hover (focusNode) if available, otherwise clicked node, otherwise latestNode\r\n        const visibilityFocus = focusNode || clickedNode || latestNode;\r\n        // For zoom: use the most recent action\r\n        const zoomFocus = lastAction === 'search' ? 'search' : \r\n                         lastAction === 'click' ? clickedNode : \r\n                         lastAction === 'latestNode' ? latestNode :\r\n                         lastAction === 'mutation' ? mutatedNodes[0] : null;\r\n        const visibilityNodes = getNDegreeNodes(visibilityFocus, visibleDegree);\r\n        \r\n        // Always include search results in visibility if there's a search term\r\n        if (inputValue && inputValue.trim()) {\r\n          const searchMatches = data.nodes.filter(node => \r\n            node.name.toLowerCase().includes(inputValue.toLowerCase()) ||\r\n            (node.location && node.location.toLowerCase().includes(inputValue.toLowerCase())) ||\r\n            (node.role && node.role.toLowerCase().includes(inputValue.toLowerCase())) ||\r\n            (node.website && node.website.toLowerCase().includes(inputValue.toLowerCase()))\r\n          );\r\n          searchMatches.forEach(match => {\r\n            const matchNeighbors = getNDegreeNodes(match.name, visibleDegree);\r\n            matchNeighbors.forEach(neighbor => visibilityNodes.add(neighbor));\r\n          });\r\n        }\r\n        \r\n        // Always include mutated nodes in visibility if there was a mutation\r\n        if (lastAction === 'mutation' && mutatedNodes.length > 0) {\r\n          mutatedNodes.forEach(nodeName => {\r\n            const nodeNeighbors = getNDegreeNodes(nodeName, 0); // Always use 0 degree for mutations\r\n            nodeNeighbors.forEach(neighbor => visibilityNodes.add(neighbor));\r\n          });\r\n        }\r\n        \r\n        const zoomNodes = lastAction === 'search' ? \r\n                         (() => {\r\n                           const searchMatches = data.nodes.filter(node => \r\n                             node.name.toLowerCase().includes(inputValue.toLowerCase()) ||\r\n                             (node.location && node.location.toLowerCase().includes(inputValue.toLowerCase())) ||\r\n                             (node.role && node.role.toLowerCase().includes(inputValue.toLowerCase())) ||\r\n                             (node.website && node.website.toLowerCase().includes(inputValue.toLowerCase()))\r\n                           );\r\n                           const searchNodes = new Set();\r\n                           searchMatches.forEach(match => {\r\n                             const matchNeighbors = getNDegreeNodes(match.name, visibleDegree);\r\n                             matchNeighbors.forEach(neighbor => searchNodes.add(neighbor));\r\n                           });\r\n                           return searchNodes;\r\n                         })() : \r\n                         lastAction === 'mutation' ?\r\n                         (() => {\r\n                           const mutationNodes = new Set();\r\n                           mutatedNodes.forEach(nodeName => {\r\n                             const nodeNeighbors = getNDegreeNodes(nodeName, 1); // Always use 1 degree for mutations\r\n                             nodeNeighbors.forEach(neighbor => mutationNodes.add(neighbor));\r\n                           });\r\n                           return mutationNodes;\r\n                         })() :\r\n                         getNDegreeNodes(zoomFocus, visibleDegree);\r\n        \r\n        // Auto-zoom to visible nodes with temporary focus behavior\r\n        useEffect(() => {\r\n          // Only run auto-zoom if it hasn't been triggered yet and we have a valid action\r\n          if (autoZoomTriggered || !fgRef.current || !lastAction) {\r\n            return;\r\n          }\r\n          \r\n          // Clear any existing focus timeout\r\n          if (focusTimeout) {\r\n            clearTimeout(focusTimeout);\r\n            setFocusTimeout(null);\r\n          }\r\n          \r\n          // Mark that auto-zoom has been triggered\r\n          setAutoZoomTriggered(true);\r\n          \r\n          // Only auto-zoom if there are nodes to zoom to\r\n          if (zoomNodes.size > 0) {\r\n            const performAutoZoom = () => {\r\n              const visibleNodes = data.nodes.filter(node => zoomNodes.has(node.name));\r\n              if (visibleNodes.length === 0) return;\r\n              \r\n              // Calculate bounding box of visible nodes\r\n              const xs = visibleNodes.map(n => n.x);\r\n              const ys = visibleNodes.map(n => n.y);\r\n              const minX = Math.min(...xs);\r\n              const maxX = Math.max(...xs);\r\n              const minY = Math.min(...ys);\r\n              const maxY = Math.max(...ys);\r\n              \r\n              const centerX = (minX + maxX) / 2;\r\n              const centerY = (minY + maxY) / 2;\r\n              const width = maxX - minX;\r\n              const height = maxY - minY;\r\n              \r\n              // Add some padding\r\n              const padding = 100;\r\n              const scale = Math.min(\r\n                (window.innerWidth - padding) / width,\r\n                (window.innerHeight - padding) / height,\r\n                2 // Max zoom level\r\n              );\r\n              \r\n              fgRef.current.centerAt(centerX, centerY, 1000);\r\n              fgRef.current.zoom(scale, 1000);\r\n              \r\n              // Set temporary focus timeout to just reset the flag (no zoom out)\r\n              const newFocusTimeout = setTimeout(() => {\r\n                setFocusTimeout(null);\r\n                setAutoZoomTriggered(false); // Reset the flag to allow future auto-zooms\r\n              }, 1000);\r\n              \r\n              setFocusTimeout(newFocusTimeout);\r\n            };\r\n            \r\n            // For latestNode and mutation, add a delay to allow graph to stabilize\r\n            if (lastAction === 'latestNode' || lastAction === 'mutation') {\r\n              setTimeout(performAutoZoom, 1000);\r\n            } else {\r\n              performAutoZoom();\r\n            }\r\n          } else {\r\n            // If no nodes to zoom to, reset the flag immediately\r\n            setAutoZoomTriggered(false);\r\n          }\r\n        }, [lastAction, clickedNode, latestNode, inputValue, mutatedNodes]); // Removed focusTimeout from dependencies\r\n\r\n        // Cleanup focus timeout and reset flags on unmount\r\n        useEffect(() => {\r\n          return () => {\r\n            if (focusTimeout) {\r\n              clearTimeout(focusTimeout);\r\n            }\r\n            setAutoZoomTriggered(false);\r\n          };\r\n        }, [focusTimeout]);\r\n\r\n        const handleInputChange = (event) => {\r\n          const input = event.target.value;\r\n          setInputValue(input);\r\n          handleChange(event); // updates CypherViz state.query too\r\n          \r\n          // Update user activity when typing\r\n          updateUserActivity();\r\n          \r\n          // Clear other actions when searching\r\n          if (input.trim()) {\r\n            setClickedNode(null);\r\n            setLastAction('search');\r\n            \r\n            // Clear any existing focus timeouts when new visual states are set\r\n            if (focusTimeout) {\r\n              clearTimeout(focusTimeout);\r\n              setFocusTimeout(null);\r\n            }\r\n            setAutoZoomTriggered(false); // Allow new auto-zoom for this search\r\n          }\r\n        };\r\n\r\n        const handleSubmit = async (e) => {\r\n          e.preventDefault();\r\n\r\n          try {\r\n            const response = await fetch(\"https://flowise-hako.onrender.com/api/v1/prediction/29e305b3-c569-4676-a454-1c4fdc380c69\", {\r\n              method: \"POST\",\r\n              headers: { \"Content-Type\": \"application/json\" },\r\n              body: JSON.stringify({ question: inputValue })\r\n            });\r\n\r\n            const data = await response.json();\r\n            let generatedQuery = data.text || data.query || \"\";\r\n            \r\n            // Clean up the query by removing markdown code blocks if present\r\n            generatedQuery = generatedQuery\r\n              .replace(/```cypher\\s*/gi, '')  // Remove opening cypher code block\r\n              .replace(/```\\s*$/gi, '')       // Remove closing code block\r\n              .replace(/^```\\s*/gi, '')       // Remove any opening code block\r\n              .trim();                        // Remove extra whitespace\r\n\r\n            // Detection for different types of requests\r\n            const question = inputValue.toLowerCase();\r\n            \r\n            // Individual node report detection (check this FIRST)\r\n            const isNodeReportRequest = (() => {\r\n              console.log(\"Checking for node report request:\", inputValue);\r\n              const nodeReportPatterns = [\r\n                /report.*(?:for|about|on)\\s+([A-Za-z\\s]+)/i,\r\n                /(?:generate|create|show)\\s+(?:a\\s+)?report.*(?:for|about|on)\\s+([A-Za-z\\s]+)/i,\r\n                /(?:analysis|summary)\\s+(?:for|about|on)\\s+([A-Za-z\\s]+)/i,\r\n                /([A-Za-z\\s]+)\\s+(?:report|analysis|summary)/i,\r\n                /(?:report|analysis|summary)\\s+for\\s+([A-Za-z\\s]+)/i\r\n              ];\r\n              \r\n              for (const pattern of nodeReportPatterns) {\r\n                const match = question.match(pattern);\r\n                if (match && match[1]) {\r\n                  const name = match[1].trim();\r\n                  // Filter out common words and action verbs that might be captured\r\n                  const excludedWords = [\r\n                    'the', 'and', 'or', 'for', 'about', 'on', 'generate', 'create', 'show', \r\n                    'analysis', 'summary', 'report', 'network', 'comprehensive', 'full'\r\n                  ];\r\n                  if (name.length > 2 && !excludedWords.includes(name.toLowerCase())) {\r\n                    // Additional check: make sure it looks like a person's name (contains space or is a single word)\r\n                    if (name.includes(' ') || name.length > 3) {\r\n                      console.log(\"Node report detected for:\", name);\r\n                      return name;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              return null;\r\n            })();\r\n\r\n            // Report request detection (check this SECOND)\r\n            const isReportRequest = (() => {\r\n              const reportKeywords = [\r\n                'report', 'analysis', 'summary', 'network analysis', 'bridge analysis', \r\n                'top connectors', 'network health', 'generate report', 'comprehensive report', \r\n                'full analysis', 'network report', 'bridge report', 'connector analysis'\r\n              ];\r\n              return reportKeywords.some(keyword => question.includes(keyword));\r\n            })();\r\n\r\n            // More specific detection for true analytical questions vs visualization requests\r\n            const isTrueAnalyticalQuestion = (() => {\r\n              const analyticalKeywords = ['how many', 'how much', 'what is', 'what are', 'when', 'where', 'why', 'who', 'which', 'how', 'what'];\r\n              \r\n              // True analytical questions that ask for specific data points\r\n              const analyticalPatterns = [\r\n                /how many/i,\r\n                /how much/i,\r\n                /what is the (count|number|total)/i,\r\n                /what are the (count|numbers|totals)/i,\r\n                /count of/i,\r\n                /total number of/i,\r\n                /how many (artists|users|people|connections|relationships)/i,\r\n                /what (roles|locations|websites) (exist|are there)/i,\r\n                /which (roles|locations|websites)/i,\r\n                /what is the most common/i,\r\n                /what is the average/i,\r\n                /how many people are (in|from)/i\r\n              ];\r\n              \r\n              // Visualization requests that should NOT be treated as analytical\r\n              const visualizationPatterns = [\r\n                /show me/i,\r\n                /display/i,\r\n                /visualize/i,\r\n                /find/i,\r\n                /search for/i,\r\n                /look for/i,\r\n                /get/i,\r\n                /bring up/i,\r\n                /open/i\r\n              ];\r\n              \r\n              // If it matches visualization patterns, it's NOT analytical\r\n              if (visualizationPatterns.some(pattern => pattern.test(question))) {\r\n                return false;\r\n              }\r\n              \r\n              // If it matches analytical patterns, it IS analytical\r\n              if (analyticalPatterns.some(pattern => pattern.test(question))) {\r\n                return true;\r\n              }\r\n              \r\n              // Default: if it contains analytical keywords but doesn't match visualization patterns\r\n              return analyticalKeywords.some(keyword => question.includes(keyword));\r\n            })();\r\n\r\n            if (isNodeReportRequest) {\r\n              // For individual node report requests\r\n              try {\r\n                const nodeName = isNodeReportRequest;\r\n                console.log(\"Generating node report for:\", nodeName);\r\n                \r\n                const session = driver.session({ database: \"neo4j\" });\r\n                \r\n                // Query for the specific node and its connections\r\n                const nodeQuery = `\r\n                  MATCH (u:User)\r\n                  WHERE toLower(u.name) = toLower($nodeName)\r\n                  OPTIONAL MATCH (u)-[r:CONNECTED_TO]->(v:User)\r\n                  RETURN u.name AS sourceName, u.role AS sourceRole, u.location AS sourceLocation, u.website AS sourceWebsite,\r\n                         v.name AS targetName, v.role AS targetRole, v.location AS targetLocation, v.website AS targetWebsite,\r\n                         r.note AS connectionNote, r.createdAt AS connectionTime\r\n                  UNION\r\n                  MATCH (v:User)-[r:CONNECTED_TO]->(u:User)\r\n                  WHERE toLower(u.name) = toLower($nodeName)\r\n                  RETURN v.name AS sourceName, v.role AS sourceRole, v.location AS sourceLocation, v.website AS sourceWebsite,\r\n                         u.name AS targetName, u.role AS targetRole, u.location AS targetLocation, u.website AS targetWebsite,\r\n                         r.note AS connectionNote, r.createdAt AS connectionTime\r\n                  UNION\r\n                  MATCH (u:User)\r\n                  WHERE toLower(u.name) = toLower($nodeName)\r\n                  AND NOT EXISTS((u)-[:CONNECTED_TO]->())\r\n                  AND NOT EXISTS(()-[:CONNECTED_TO]->(u))\r\n                  RETURN u.name AS sourceName, u.role AS sourceRole, u.location AS sourceLocation, u.website AS sourceWebsite,\r\n                         null AS targetName, null AS targetRole, null AS targetLocation, null AS targetWebsite,\r\n                         null AS connectionNote, null AS connectionTime\r\n                `;\r\n                \r\n                let result = await session.run(nodeQuery, { nodeName });\r\n                console.log(\"Node query result:\", result.records.length, \"records\");\r\n                if (result.records.length > 0) {\r\n                  console.log(\"First record:\", result.records[0].toObject());\r\n                }\r\n                \r\n                // If no results, try a fuzzy search\r\n                if (result.records.length === 0) {\r\n                  console.log(\"No exact match found, trying fuzzy search...\");\r\n                  const fuzzyQuery = `\r\n                    MATCH (u:User)\r\n                    WHERE toLower(u.name) CONTAINS toLower($nodeName)\r\n                    RETURN u.name AS name, u.role AS role, u.location AS location\r\n                    LIMIT 5\r\n                  `;\r\n                  const fuzzyResult = await session.run(fuzzyQuery, { nodeName });\r\n                  \r\n                  if (fuzzyResult.records.length > 0) {\r\n                    const suggestions = fuzzyResult.records.map(record => record.get('name')).join(', ');\r\n                    await session.close();\r\n                    displayNetworkReport(`No exact match found for \"${nodeName}\". Did you mean one of these?\\n\\n${suggestions}\\n\\nPlease try with the exact name.`, `Name Not Found: ${nodeName}`);\r\n                    return;\r\n                  }\r\n                }\r\n                \r\n                await session.close();\r\n\r\n                // Generate a node-specific report\r\n                const report = generateNodeReport(result, nodeName, inputValue);\r\n                \r\n                // Display the report in a modal\r\n                displayNetworkReport(report, `Node Analysis: ${nodeName}`);\r\n                \r\n                // Clear the input after showing the report\r\n                setTimeout(() => {\r\n                  setInputValue(\"\");\r\n                }, 10000);\r\n                \r\n              } catch (queryError) {\r\n                console.error(\"Error generating node report:\", queryError);\r\n                displayNetworkReport(`Sorry, I couldn't generate a report for that person. Please check the name and try again.`, inputValue);\r\n              }\r\n            } else if (isReportRequest) {\r\n              // For general report requests, execute the query and generate a comprehensive report\r\n              try {\r\n                const session = driver.session({ database: \"neo4j\" });\r\n                const result = await session.run(generatedQuery);\r\n                await session.close();\r\n\r\n                // Generate a comprehensive network analysis report\r\n                const report = generateNetworkReport(result, inputValue);\r\n                \r\n                // Display the report in a modal or notification\r\n                displayNetworkReport(report, inputValue);\r\n                \r\n                // Clear the input after showing the report\r\n                setTimeout(() => {\r\n                  setInputValue(\"\");\r\n                }, 10000); // Keep report visible longer\r\n                \r\n              } catch (queryError) {\r\n                console.error(\"Error generating report:\", queryError);\r\n                displayNetworkReport(\"Sorry, I couldn't generate the report. Please try again.\", inputValue);\r\n              }\r\n            } else if (isTrueAnalyticalQuestion) {\r\n              // For analytical questions, execute the query and provide a text answer\r\n              try {\r\n                const session = driver.session({ database: \"neo4j\" });\r\n                const result = await session.run(generatedQuery);\r\n                await session.close();\r\n\r\n                // Generate a human-readable answer based on the query results\r\n                const answer = generateAnalyticalAnswer(inputValue, result, generatedQuery);\r\n                \r\n                // Display the answer in a modal or notification\r\n                displayAnalyticalAnswer(answer, inputValue);\r\n                \r\n                // Clear the input after showing the answer\r\n                setTimeout(() => {\r\n                  setInputValue(\"\");\r\n                }, 5000); // Keep answer visible longer for analytical questions\r\n                \r\n              } catch (queryError) {\r\n                console.error(\"Error executing analytical query:\", queryError);\r\n                displayAnalyticalAnswer(\"Sorry, I couldn't analyze that question. Please try rephrasing it.\", inputValue);\r\n              }\r\n            } else {\r\n              // For regular queries, proceed with the existing logic\r\n              setInputValue(generatedQuery);\r\n              handleChange({ target: { value: generatedQuery } });\r\n\r\n              await loadData(null, generatedQuery);\r\n\r\n              // Check if the generated query is a mutation query (updates the graph)\r\n              const isMutationQuery = /(CREATE|MERGE|SET|DELETE|REMOVE|DETACH DELETE)/i.test(generatedQuery.trim());\r\n              \r\n              // If it's a mutation query, immediately return to default state\r\n              if (isMutationQuery) {\r\n                \r\n                // Extract node names from the mutation query to track what was created/modified\r\n                let extractedNodes = [];\r\n                \r\n                // Handle different mutation query patterns\r\n                if (generatedQuery.includes('DELETE')) {\r\n                  // For DELETE queries, extract from patterns like DELETE (u:User {name: \"John\"}) or MATCH (u:User {name: \"John\"}) DELETE u\r\n                  const deleteMatches = generatedQuery.match(/\\{name:\\s*['\"]([^'\"]+)['\"]\\}/g);\r\n                  if (deleteMatches) {\r\n                    extractedNodes = deleteMatches.map(match => {\r\n                      const nameMatch = match.match(/name:\\s*['\"]([^'\"]+)['\"]/);\r\n                      return nameMatch ? nameMatch[1] : null;\r\n                    }).filter(Boolean);\r\n                  }\r\n                } else if (generatedQuery.includes('SET')) {\r\n                  // For SET queries, extract from MATCH clause like MATCH (u:User {name: \"John\"}) SET u.role = 'admin'\r\n                  const matchClause = generatedQuery.match(/MATCH\\s*\\([^)]*\\{name:\\s*['\"]([^'\"]+)['\"][^}]*\\}\\)/i);\r\n                  if (matchClause) {\r\n                    extractedNodes = [matchClause[1]];\r\n                  }\r\n                } else {\r\n                  // For CREATE/MERGE queries, extract from {name: \"nodeName\"} patterns\r\n                  const nodeMatches = generatedQuery.match(/\\{([^}]+)\\}/g);\r\n                  extractedNodes = nodeMatches ? \r\n                    nodeMatches.map(match => {\r\n                      const nameMatch = match.match(/name:\\s*['\"]([^'\"]+)['\"]/);\r\n                      return nameMatch ? nameMatch[1] : null;\r\n                    }).filter(Boolean) : [];\r\n                }\r\n                \r\n                setMutatedNodes(extractedNodes);\r\n                setLastAction('mutation');\r\n                \r\n                // Clear any existing focus timeouts when new visual states are set\r\n                if (focusTimeout) {\r\n                  clearTimeout(focusTimeout);\r\n                  setFocusTimeout(null);\r\n                }\r\n                setAutoZoomTriggered(false); // Allow new auto-zoom for this mutation\r\n                \r\n                // Immediately return to default query without any delay\r\n                const defaultQuery = `\r\n                  MATCH (u:User)-[r:CONNECTED_TO]->(v:User)\r\n                  RETURN u.name AS source, u.role AS sourceRole, u.location AS sourceLocation, u.website AS sourceWebsite, \r\n                         v.name AS target, v.role AS targetRole, v.location AS targetLocation, v.website AS targetWebsite\r\n                `;\r\n                await loadData(null, defaultQuery);\r\n              }\r\n              \r\n              // Clear the input after 3 seconds\r\n              setTimeout(() => {\r\n                setInputValue(\"\");\r\n              }, 3000);\r\n            }\r\n            \r\n            } catch (error) {\r\n              console.error(\"Flowise call failed:\", error);\r\n            }\r\n        };\r\n\r\n        // Helper function to check if a node is new (created via NFC)\r\n        const isNewNode = (node) => {\r\n          return node.name === latestNode;\r\n        };\r\n\r\n        const handleNodeClick = (node) => {\r\n          if (!node) return;\r\n          setSelectedNode(node);\r\n          setEditedNode({ ...node });\r\n          setFocusNode(node.name);\r\n          setClickedNode(node.name);\r\n          setLastAction('click');\r\n          \r\n          // Clear relationship note when clicking a different node\r\n          setRelationshipNote(\"\");\r\n          \r\n          // Update user activity when clicking nodes\r\n          updateUserActivity();\r\n          \r\n          // Clear search when clicking a node to avoid zoom conflicts\r\n          setInputValue(\"\");\r\n          \r\n          // Clear any existing focus timeout and reset auto-zoom flag\r\n          if (focusTimeout) {\r\n            clearTimeout(focusTimeout);\r\n            setFocusTimeout(null);\r\n          }\r\n          setAutoZoomTriggered(false); // Allow new auto-zoom for this click\r\n        };\r\n\r\n        const handleNodeHover = (node) => {\r\n          if (node) {\r\n            setFocusNode(node.name);\r\n          } else {\r\n            setFocusNode(null);\r\n          }\r\n        };\r\n\r\n        const handleLinkClick = async (link) => {\r\n          if (!link) return;\r\n          \r\n          const sourceName = typeof link.source === 'object' ? link.source.name : link.source;\r\n          const targetName = typeof link.target === 'object' ? link.target.name : link.target;\r\n          \r\n          console.log(`Link clicked: ${sourceName} -> ${targetName}`);\r\n          \r\n          const session = driver.session();\r\n          try {\r\n            // Get relationship data including notes\r\n            const relationshipResult = await session.run(\r\n              `MATCH (source:User {name: $sourceName})-[r:CONNECTED_TO]->(target:User {name: $targetName})\r\n               RETURN r.note as note, source.name as sourceName, target.name as targetName`,\r\n              { sourceName: sourceName, targetName: targetName }\r\n            );\r\n            \r\n            if (relationshipResult.records.length > 0) {\r\n              const record = relationshipResult.records[0];\r\n              const note = record.get('note');\r\n              \r\n              setSelectedLink(link);\r\n              setRelationshipData({\r\n                sourceName: sourceName,\r\n                targetName: targetName,\r\n                note: note\r\n              });\r\n              \r\n              console.log(`Relationship data: ${sourceName} -> ${targetName}, Note: ${note}`);\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error fetching relationship data:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        const handleLinkHover = async (link) => {\r\n          if (!link) {\r\n            setHoveredLink(null);\r\n            return;\r\n          }\r\n          \r\n          const sourceName = typeof link.source === 'object' ? link.source.name : link.source;\r\n          const targetName = typeof link.target === 'object' ? link.target.name : link.target;\r\n          \r\n          const session = driver.session();\r\n          try {\r\n            // Get relationship data including notes\r\n            const relationshipResult = await session.run(\r\n              `MATCH (source:User {name: $sourceName})-[r:CONNECTED_TO]->(target:User {name: $targetName})\r\n               RETURN r.note as note, source.name as sourceName, target.name as targetName`,\r\n              { sourceName: sourceName, targetName: targetName }\r\n            );\r\n            \r\n            if (relationshipResult.records.length > 0) {\r\n              const record = relationshipResult.records[0];\r\n              const note = record.get('note');\r\n              \r\n              setHoveredLink({\r\n                link: link,\r\n                sourceName: sourceName,\r\n                targetName: targetName,\r\n                note: note\r\n              });\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error fetching relationship data:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        const handleEditChange = (event) => {\r\n          const { name, value } = event.target;\r\n          setEditedNode((prev) => ({\r\n            ...prev,\r\n            [name]: value,\r\n          }));\r\n        };\r\n\r\n        const saveNodeChanges = async () => {\r\n          if (!editedNode || !selectedNode) return;\r\n\r\n          // Helper function to capitalize first letter of each word\r\n          const capitalizeWords = (str) => {\r\n            if (!str) return str;\r\n            return str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\r\n          };\r\n\r\n          const newName = capitalizeWords(editedNode.name);\r\n          const oldName = selectedNode.name;\r\n\r\n          // Don't do anything if the name hasn't changed\r\n          if (newName === oldName) {\r\n            setSelectedNode(null); // Close the panel\r\n            return;\r\n          }\r\n\r\n          const session = driver.session();\r\n          try {\r\n            // First, check if a node with the new name already exists\r\n            const existingNodeCheck = await session.run(\r\n              `MATCH (u:User {name: $newName}) RETURN u`,\r\n              { newName: newName }\r\n            );\r\n\r\n            if (existingNodeCheck.records.length > 0) {\r\n              // A node with the new name already exists - merge them\r\n              console.log(`Node with name \"${newName}\" already exists, merging with existing node...`);\r\n              \r\n              // Get the existing node's properties\r\n              const existingNode = existingNodeCheck.records[0].get('u').properties;\r\n              \r\n              // Merge properties: keep non-empty values from either node\r\n              const mergedRole = existingNode.role && existingNode.role !== '' ? existingNode.role : editedNode.role;\r\n              const mergedLocation = existingNode.location && existingNode.location !== '' ? existingNode.location : editedNode.location;\r\n              const mergedWebsite = existingNode.website && existingNode.website !== '' ? existingNode.website : editedNode.website;\r\n              \r\n              // Efficiently merge all relationships and delete old node in a single operation\r\n              await session.run(\r\n                `MATCH (old:User {name: $oldName})\r\n                 OPTIONAL MATCH (old)-[r1:CONNECTED_TO]->(other1)\r\n                 OPTIONAL MATCH (other2)-[r2:CONNECTED_TO]->(old)\r\n                 WITH old, collect(DISTINCT other1) as outgoing, collect(DISTINCT other2) as incoming\r\n                 MATCH (existing:User {name: $newName})\r\n                 \r\n                 // Create outgoing relationships (avoiding self-connections and duplicates)\r\n                 FOREACH (other IN outgoing |\r\n                   FOREACH (x IN CASE WHEN other.name <> $newName AND NOT EXISTS((existing)-[:CONNECTED_TO]->(other)) THEN [1] ELSE [] END |\r\n                     CREATE (existing)-[r:CONNECTED_TO]->(other)\r\n                     SET r.createdAt = $timestamp\r\n                   )\r\n                 )\r\n                 \r\n                 // Create incoming relationships (avoiding self-connections and duplicates)\r\n                 FOREACH (other IN incoming |\r\n                   FOREACH (x IN CASE WHEN other.name <> $newName AND NOT EXISTS((other)-[:CONNECTED_TO]->(existing)) THEN [1] ELSE [] END |\r\n                     CREATE (other)-[r:CONNECTED_TO]->(existing)\r\n                     SET r.createdAt = $timestamp\r\n                   )\r\n                 )\r\n                 \r\n                 // Delete the old node\r\n                 DETACH DELETE old`,\r\n                { oldName: oldName, newName: newName, timestamp: Date.now() }\r\n              );\r\n              \r\n              // Update the existing node with merged properties\r\n              await session.run(\r\n                `MATCH (u:User {name: $newName})\r\n                 SET u.role = $role, u.location = $location, u.website = $website`,\r\n                {\r\n                  newName: newName,\r\n                  role: mergedRole,\r\n                  location: mergedLocation,\r\n                  website: mergedWebsite\r\n                }\r\n              );\r\n              \r\n              console.log(`Successfully merged nodes. New node \"${newName}\" has properties:`, { mergedRole, mergedLocation, mergedWebsite });\r\n              \r\n              // Focus on the merged node\r\n              await loadData(newName);\r\n              setSelectedNode(null); // Close the panel\r\n            } else {\r\n              // No existing node with the new name, just update the current node\r\n            await session.run(\r\n              `MATCH (u:User {name: $oldName}) \r\n              SET u.name = $newName`,\r\n                {\r\n                  oldName: oldName,\r\n                  newName: newName,\r\n                }\r\n              );\r\n              await loadData(newName); // Keep the edited node as latestNode\r\n              setSelectedNode(null); // Close the panel\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error updating node:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        const saveNewNodeProfile = async () => {\r\n          if (!editedNode || !selectedNode) return;\r\n\r\n          // Helper function to capitalize first letter of each word\r\n          const capitalizeWords = (str) => {\r\n            if (!str) return str;\r\n            return str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\r\n          };\r\n\r\n          const session = driver.session();\r\n          try {\r\n            await session.run(\r\n              `MATCH (u:User {name: $oldName}) \r\n              SET u.name = $newName, u.role = $role, u.location = $location, u.website = $website`,\r\n              {\r\n                oldName: selectedNode.name,\r\n                newName: capitalizeWords(editedNode.name),\r\n                role: editedNode.role || '',\r\n                location: editedNode.location || '',\r\n                website: editedNode.website || ''\r\n              }\r\n            );\r\n            await loadData(capitalizeWords(editedNode.name));\r\n            setSelectedNode(null); // Close the panel\r\n          } catch (error) {\r\n            console.error(\"Error updating new node profile:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        const saveRelationshipNote = async () => {\r\n          if (!selectedNode || !relationshipNote.trim()) return;\r\n\r\n          const session = driver.session();\r\n          try {\r\n            let sourceName, targetName;\r\n            \r\n            if (showNfcRelationshipPopup) {\r\n              // This is an NFC operation - use the tracked connection\r\n              if (currentNfcConnection) {\r\n                sourceName = currentNfcConnection.source;\r\n                targetName = currentNfcConnection.target;\r\n              } else {\r\n                // Fallback: try to find the connection\r\n                const fallbackResult = await session.run(\r\n                  `MATCH (source:User)-[r:CONNECTED_TO]->(target:User {name: $holderName})\r\n                   RETURN source.name as sourceName, target.name as targetName\r\n                   ORDER BY source.name DESC\r\n                   LIMIT 1`,\r\n                  { holderName: selectedNode.name }\r\n                );\r\n                \r\n                if (fallbackResult.records.length > 0) {\r\n                  const record = fallbackResult.records[0];\r\n                  sourceName = record.get('sourceName');\r\n                  targetName = record.get('targetName');\r\n                }\r\n              }\r\n            } else {\r\n              // This is a regular relationship note - use the existing logic\r\n              const nfcHolderResult = await session.run(\r\n                `MATCH (existing:User {name: $existingName})-[r:CONNECTED_TO]->(holder:User)\r\n                 RETURN holder.name as holderName`,\r\n                { existingName: selectedNode.name }\r\n              );\r\n              \r\n              const nfcHolderName = nfcHolderResult.records[0]?.get('holderName');\r\n              \r\n              if (nfcHolderName) {\r\n                sourceName = selectedNode.name;\r\n                targetName = nfcHolderName;\r\n              }\r\n            }\r\n            \r\n            if (sourceName && targetName) {\r\n              // Add the relationship note as a property to the connection\r\n              const updateResult = await session.run(\r\n                `MATCH (source:User {name: $sourceName})-[r:CONNECTED_TO]->(target:User {name: $targetName})\r\n                 SET r.note = $note\r\n                 RETURN r.note as updatedNote`,\r\n                {\r\n                  sourceName: sourceName,\r\n                  targetName: targetName,\r\n                  note: relationshipNote.trim()\r\n                }\r\n              );\r\n              \r\n              if (updateResult.records.length > 0) {\r\n                const updatedNote = updateResult.records[0].get('updatedNote');\r\n              }\r\n            }\r\n            \r\n            setSelectedNode(null); // Close the panel\r\n            setRelationshipNote(\"\"); // Clear the note\r\n            setPendingNfcName(\"\"); // Clear pending name\r\n            setShowNfcRelationshipPopup(false); // Close NFC relationship popup\r\n            setCurrentNfcConnection(null); // Clear the tracked connection\r\n          } catch (error) {\r\n            console.error(\"Error saving relationship note:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        const handleNfcNameSubmit = async () => {\r\n          if (!nfcNameInput.trim()) return;\r\n\r\n          // Helper function to capitalize first letter of each word\r\n          const capitalizeWords = (str) => {\r\n            if (!str) return str;\r\n            return str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\r\n          };\r\n\r\n          const capitalizedName = capitalizeWords(nfcNameInput.trim());\r\n          setPendingNfcName(capitalizedName);\r\n\r\n          const session = driver.session();\r\n          try {\r\n            // Check if a node with this name already exists\r\n            const existingNodeCheck = await session.run(\r\n              `MATCH (u:User {name: $name}) RETURN u`,\r\n              { name: capitalizedName }\r\n            );\r\n\r\n            if (existingNodeCheck.records.length > 0) {\r\n              // Node exists - merge visitor into existing node and show connection note popup\r\n              console.log(`Node \"${capitalizedName}\" exists, merging visitor into existing node`);\r\n              \r\n              const existingNode = existingNodeCheck.records[0].get('u').properties;\r\n              \r\n              // Get the NFC holder name from the visitor's connection\r\n              const nfcHolderResult = await session.run(\r\n                `MATCH (visitor:User {name: $visitorName})-[r:CONNECTED_TO]->(holder:User)\r\n                 RETURN holder.name as holderName`,\r\n                { visitorName: latestNode }\r\n              );\r\n              \r\n              const nfcHolderName = nfcHolderResult.records[0]?.get('holderName');\r\n              \r\n              if (nfcHolderName) {\r\n                // Store the connection details for the relationship note\r\n                setCurrentNfcConnection({\r\n                  source: capitalizedName,\r\n                  target: nfcHolderName\r\n                });\r\n                \r\n                // Check if the existing node is already connected to the NFC holder\r\n                const existingConnectionCheck = await session.run(\r\n                  `MATCH (existing:User {name: $existingName})-[r:CONNECTED_TO]->(holder:User {name: $holderName})\r\n                   RETURN r`,\r\n                  { existingName: capitalizedName, holderName: nfcHolderName }\r\n                );\r\n                \r\n                if (existingConnectionCheck.records.length === 0) {\r\n                  // No existing connection, create one\r\n                  await session.run(\r\n                    `MATCH (existing:User {name: $existingName}), (holder:User {name: $holderName})\r\n                     CREATE (existing)-[r:CONNECTED_TO]->(holder)\r\n                     SET r.createdAt = $timestamp`,\r\n                    { existingName: capitalizedName, holderName: nfcHolderName, timestamp: Date.now() }\r\n                  );\r\n                  console.log(`Created new connection from \"${capitalizedName}\" to \"${nfcHolderName}\"`);\r\n                } else {\r\n                  console.log(`Connection from \"${capitalizedName}\" to \"${nfcHolderName}\" already exists`);\r\n                }\r\n                \r\n                // Delete the visitor node\r\n                await session.run(\r\n                  `MATCH (visitor:User {name: $visitorName})\r\n                   DETACH DELETE visitor`,\r\n                  { visitorName: latestNode }\r\n                );\r\n                \r\n                console.log(`Merged visitor into existing node \"${capitalizedName}\"`);\r\n              }\r\n              \r\n              setShowNfcNamePopup(false);\r\n              setNfcNameInput(\"\");\r\n              setNfcRoleInput(\"\");\r\n              setSelectedNode(existingNode);\r\n              setRelationshipNote(\"\");\r\n              setShowNfcRelationshipPopup(true); // Show NFC relationship note popup\r\n              \r\n              // Don't reload data to avoid triggering duplicate cleanup again\r\n              // Just focus on the existing node\r\n              console.log(`Merged visitor into existing node \"${capitalizedName}\", focusing on existing node`);\r\n              \r\n              // Update the latestNode to the existing node so it gets focused\r\n              // We'll let the user manually refresh if needed\r\n            } else {\r\n              // Node doesn't exist - show profile completion popup\r\n              console.log(`Node \"${capitalizedName}\" doesn't exist, showing profile completion popup`);\r\n              setShowNfcNamePopup(false);\r\n              setNfcNameInput(\"\");\r\n              setNfcRoleInput(\"\");\r\n              setShowProfilePopup(true);\r\n              setSelectedNode({ name: capitalizedName, role: nfcRoleInput, location: \"\", website: \"\" });\r\n              setEditedNode({ name: capitalizedName, role: nfcRoleInput, location: \"\", website: \"\" });\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error checking for existing node:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        const saveNewProfileFromNfc = async () => {\r\n          if (!editedNode || !pendingNfcName) return;\r\n\r\n          const session = driver.session();\r\n          try {\r\n            // Update the visitor node with the new name and profile information\r\n            await session.run(\r\n              `MATCH (visitor:User {name: $visitorName}) \r\n               SET visitor.name = $newName, visitor.role = $role, visitor.location = $location, visitor.website = $website`,\r\n              {\r\n                visitorName: latestNode,\r\n                newName: editedNode.name,\r\n                role: editedNode.role || '',\r\n                location: editedNode.location || '',\r\n                website: editedNode.website || ''\r\n              }\r\n            );\r\n            \r\n            console.log(`Updated visitor profile: ${editedNode.name} with role: ${editedNode.role}, location: ${editedNode.location}, website: ${editedNode.website}`);\r\n            setShowProfilePopup(false);\r\n            \r\n            // Get the NFC holder name from the visitor's connection\r\n            const nfcHolderResult = await session.run(\r\n              `MATCH (visitor:User {name: $visitorName})-[r:CONNECTED_TO]->(holder:User)\r\n               RETURN holder.name as holderName`,\r\n              { visitorName: editedNode.name }\r\n            );\r\n            \r\n            const nfcHolderName = nfcHolderResult.records[0]?.get('holderName');\r\n            \r\n            if (nfcHolderName) {\r\n              // Store the connection details for the relationship note\r\n              setCurrentNfcConnection({\r\n                source: editedNode.name,\r\n                target: nfcHolderName\r\n              });\r\n              \r\n              // Show connection note popup for the new user\r\n              setSelectedNode({ name: nfcHolderName, role: \"\", location: \"\", website: \"\" });\r\n              setRelationshipNote(\"\");\r\n              setShowNfcRelationshipPopup(true);\r\n            } else {\r\n              // No NFC holder found, just close the popup\r\n              setSelectedNode(null);\r\n              setEditedNode(null);\r\n              setPendingNfcName(\"\");\r\n              setCurrentNfcConnection(null);\r\n            }\r\n            \r\n            // Reload data to show the updated node\r\n            await loadData(editedNode.name);\r\n          } catch (error) {\r\n            console.error(\"Error saving new profile from NFC:\", error);\r\n          } finally {\r\n            session.close();\r\n          }\r\n        };\r\n\r\n        // Helper function to generate human-readable answers from query results\r\n        const generateAnalyticalAnswer = (question, result, query) => {\r\n          const questionLower = question.toLowerCase();\r\n          const records = result.records;\r\n          \r\n          // Debug logging to see what's happening\r\n          console.log(\"Analytical question:\", question);\r\n          console.log(\"Generated query:\", query);\r\n          console.log(\"Query result:\", result);\r\n          console.log(\"Records:\", records);\r\n          \r\n          if (records.length === 0) {\r\n            return \"I couldn't find any data matching your question.\";\r\n          }\r\n\r\n          // Handle count queries\r\n          if (questionLower.includes('how many') || questionLower.includes('count')) {\r\n            const count = records[0].get(0);\r\n            \r\n            // Debug: Log the actual query and result for count queries\r\n            console.log(\"Count query result:\", count);\r\n            console.log(\"Question was:\", question);\r\n            \r\n            if (questionLower.includes('artist')) {\r\n              return `There are ${count} artists.`;\r\n            } else if (questionLower.includes('user')) {\r\n              return `There are ${count} users.`;\r\n            } else if (questionLower.includes('connection') || questionLower.includes('relationship')) {\r\n              return `There are ${count} connections.`;\r\n            } else if (questionLower.includes('craftsman')) {\r\n              return `There are ${count} craftsmen.`;\r\n            } else if (questionLower.includes('entrepreneur')) {\r\n              return `There are ${count} entrepreneurs.`;\r\n            } else if (questionLower.includes('educational institution') || questionLower.includes('institution')) {\r\n              return `There are ${count} educational institutions.`;\r\n            } else if (questionLower.includes('holder')) {\r\n              return `There are ${count} holder.`;\r\n            } else if (questionLower.includes('program')) {\r\n              return `There are ${count} program.`;\r\n            } else {\r\n              return `The count is ${count}.`;\r\n            }\r\n          }\r\n\r\n          // Handle location-based queries\r\n          if (questionLower.includes('where') || questionLower.includes('location')) {\r\n            let locations = [];\r\n            \r\n            // Try different case variations for location field\r\n            if (records[0].keys && records[0].keys.includes('location')) {\r\n              locations = records.map(record => record.get('location')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('Location')) {\r\n              locations = records.map(record => record.get('Location')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_location')) {\r\n              locations = records.map(record => record.get('u_location')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_Location')) {\r\n              locations = records.map(record => record.get('u_Location')).filter(Boolean);\r\n            } else {\r\n              locations = records.map(record => record.get(0)).filter(Boolean);\r\n            }\r\n            \r\n            const uniqueLocations = [...new Set(locations)];\r\n            if (uniqueLocations.length === 1) {\r\n              return `The location is ${uniqueLocations[0]}.`;\r\n            } else {\r\n              return `The locations found are: ${uniqueLocations.join(', ')}.`;\r\n            }\r\n          }\r\n\r\n          // Handle role-based queries\r\n          if (questionLower.includes('role') || questionLower.includes('what do')) {\r\n            let roles = [];\r\n            \r\n            // Try different case variations for role field\r\n            if (records[0].keys && records[0].keys.includes('role')) {\r\n              roles = records.map(record => record.get('role')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('Role')) {\r\n              roles = records.map(record => record.get('Role')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_role')) {\r\n              roles = records.map(record => record.get('u_role')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_Role')) {\r\n              roles = records.map(record => record.get('u_Role')).filter(Boolean);\r\n            } else {\r\n              roles = records.map(record => record.get(0)).filter(Boolean);\r\n            }\r\n            \r\n            const uniqueRoles = [...new Set(roles)];\r\n            if (uniqueRoles.length === 1) {\r\n              return `The role is ${uniqueRoles[0]}.`;\r\n            } else {\r\n              return `The roles found are: ${uniqueRoles.join(', ')}.`;\r\n            }\r\n          }\r\n\r\n          // Handle name-based queries\r\n          if (questionLower.includes('who') || questionLower.includes('name')) {\r\n            let names = [];\r\n            \r\n            // Try different case variations for name field\r\n            if (records[0].keys && records[0].keys.includes('name')) {\r\n              names = records.map(record => record.get('name')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('Name')) {\r\n              names = records.map(record => record.get('Name')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_name')) {\r\n              names = records.map(record => record.get('u_name')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_Name')) {\r\n              names = records.map(record => record.get('u_Name')).filter(Boolean);\r\n            } else {\r\n              names = records.map(record => record.get(0)).filter(Boolean);\r\n            }\r\n            \r\n            if (names.length === 1) {\r\n              return `The person is ${names[0]}.`;\r\n            } else if (names.length <= 5) {\r\n              return `The people are: ${names.join(', ')}.`;\r\n            } else {\r\n              return `Found ${names.length} people: ${names.slice(0, 3).join(', ')} and ${names.length - 3} more.`;\r\n            }\r\n          }\r\n\r\n          // Handle \"what roles exist\" specifically\r\n          if (questionLower.includes('what roles exist') || questionLower.includes('what roles are there')) {\r\n            // Try to extract roles from different possible result formats\r\n            let roles = [];\r\n            \r\n            // Check if the query returned role data - try different case variations\r\n            if (records[0].keys && records[0].keys.includes('role')) {\r\n              roles = records.map(record => record.get('role')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('Role')) {\r\n              roles = records.map(record => record.get('Role')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_role')) {\r\n              roles = records.map(record => record.get('u_role')).filter(Boolean);\r\n            } else if (records[0].keys && records[0].keys.includes('u_Role')) {\r\n              roles = records.map(record => record.get('u_Role')).filter(Boolean);\r\n            } else {\r\n              // Try to get the first column as roles\r\n              roles = records.map(record => record.get(0)).filter(Boolean);\r\n            }\r\n            \r\n            const uniqueRoles = [...new Set(roles)];\r\n            if (uniqueRoles.length > 0) {\r\n              return `The roles found in the network are: ${uniqueRoles.join(', ')}.`;\r\n            } else {\r\n              return \"I couldn't find any role information in the network.\";\r\n            }\r\n          }\r\n\r\n          // Default response for other queries\r\n          const resultCount = records.length;\r\n          if (resultCount === 1) {\r\n            return \"I found 1 result matching your question.\";\r\n          } else {\r\n            return `I found ${resultCount} results matching your question.`;\r\n          }\r\n        };\r\n\r\n        // Helper function to display analytical answers\r\n        const displayAnalyticalAnswer = (answer, question) => {\r\n          setAnalyticalAnswer({ answer, question });\r\n          setShowAnalyticalModal(true);\r\n          \r\n          // Auto-hide after 8 seconds\r\n          setTimeout(() => {\r\n            setShowAnalyticalModal(false);\r\n            setAnalyticalAnswer(null);\r\n          }, 8000);\r\n        };\r\n\r\n        // Helper function to generate comprehensive network analysis reports\r\n        const generateNetworkReport = (result, question) => {\r\n          const records = result.records;\r\n          \r\n          if (records.length === 0) {\r\n            return \"No network data found to analyze.\";\r\n          }\r\n\r\n          // Parse the network data\r\n          const connections = [];\r\n          const users = new Map();\r\n          const userConnections = new Map();\r\n\r\n          records.forEach(record => {\r\n            const sourceName = record.get('sourceName');\r\n            const sourceRole = record.get('sourceRole');\r\n            const sourceLocation = record.get('sourceLocation');\r\n            const targetName = record.get('targetName');\r\n            const targetRole = record.get('targetRole');\r\n            const targetLocation = record.get('targetLocation');\r\n            const connectionNote = record.get('connectionNote');\r\n            const connectionTime = record.get('connectionTime');\r\n\r\n            // Add users to the map\r\n            if (sourceName) {\r\n              users.set(sourceName, {\r\n                name: sourceName,\r\n                role: sourceRole,\r\n                location: sourceLocation\r\n              });\r\n            }\r\n            if (targetName) {\r\n              users.set(targetName, {\r\n                name: targetName,\r\n                role: targetRole,\r\n                location: targetLocation\r\n              });\r\n            }\r\n\r\n            // Count connections per user\r\n            if (sourceName && targetName) {\r\n              userConnections.set(sourceName, (userConnections.get(sourceName) || 0) + 1);\r\n              userConnections.set(targetName, (userConnections.get(targetName) || 0) + 1);\r\n              \r\n              connections.push({\r\n                source: sourceName,\r\n                target: targetName,\r\n                note: connectionNote,\r\n                time: connectionTime\r\n              });\r\n            }\r\n          });\r\n\r\n          // Find top connectors\r\n          const topConnectors = Array.from(userConnections.entries())\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 10)\r\n            .map(([name, count]) => ({ name, count }));\r\n\r\n          // Analyze demographics\r\n          const locations = Array.from(users.values()).map(u => u.location).filter(Boolean);\r\n          const uniqueLocations = [...new Set(locations)];\r\n          const roles = Array.from(users.values()).map(u => u.role).filter(Boolean);\r\n          const uniqueRoles = [...new Set(roles)];\r\n\r\n          // Generate the report\r\n          const report = `# 📊 **Network Analysis Report**\r\n\r\n## **🎯 Executive Summary**\r\n- **Total Users**: ${users.size}\r\n- **Total Connections**: ${connections.length}\r\n- **Top Connector**: ${topConnectors[0]?.name || 'N/A'} (${topConnectors[0]?.count || 0} connections)\r\n- **Network Health**: ${connections.length > users.size * 2 ? 'Excellent' : connections.length > users.size ? 'Good' : 'Needs Improvement'}\r\n\r\n## **🏆 Top Network Connectors**\r\n${topConnectors.slice(0, 5).map((connector, index) => \r\n  `${index + 1}. **${connector.name}** - ${connector.count} connections`\r\n).join('\\n')}\r\n\r\n## **🌍 Demographics & Participation**\r\n- **Geographic Diversity**: ${uniqueLocations.length} unique locations\r\n- **Professional Diversity**: ${uniqueRoles.length} unique roles\r\n- **Participation Rate**: ${Math.round((connections.length / (users.size * (users.size - 1) / 2)) * 100)}% of possible connections\r\n\r\n## **📈 Network Statistics**\r\n| Metric | Value |\r\n|--------|-------|\r\n| **Total Users** | ${users.size} |\r\n| **Total Connections** | ${connections.length} |\r\n| **Average Connections per User** | ${Math.round(connections.length / users.size * 2)} |\r\n| **Unique Locations** | ${uniqueLocations.length} |\r\n| **Unique Roles** | ${uniqueRoles.length} |\r\n\r\n## **💡 Key Insights**\r\n- The network shows ${connections.length > users.size * 2 ? 'strong' : connections.length > users.size ? 'moderate' : 'limited'} connectivity\r\n- Top connectors demonstrate effective networking skills\r\n- Geographic and professional diversity enhance network value\r\n\r\n## **🎯 Recommendations**\r\n- Encourage more connections between different communities\r\n- Support bridge nodes to maintain network resilience\r\n- Foster cross-cultural and cross-professional connections`;\r\n\r\n          return report;\r\n        };\r\n\r\n        // Helper function to generate individual node analysis reports\r\n        const generateNodeReport = (result, nodeName, question) => {\r\n          const records = result.records;\r\n          \r\n          console.log(\"generateNodeReport called with:\", { nodeName, recordCount: records.length });\r\n          \r\n          if (records.length === 0) {\r\n            return `No data found for ${nodeName}. Please check the name and try again.`;\r\n          }\r\n\r\n          // Parse the node data\r\n          const connections = [];\r\n          const nodeInfo = {};\r\n          const connectedUsers = new Map();\r\n\r\n          records.forEach((record, index) => {\r\n            const sourceName = record.get('sourceName');\r\n            const sourceRole = record.get('sourceRole');\r\n            const sourceLocation = record.get('sourceLocation');\r\n            const sourceWebsite = record.get('sourceWebsite');\r\n            const targetName = record.get('targetName');\r\n            const targetRole = record.get('targetRole');\r\n            const targetLocation = record.get('targetLocation');\r\n            const targetWebsite = record.get('targetWebsite');\r\n            const connectionNote = record.get('connectionNote');\r\n            const connectionTime = record.get('connectionTime');\r\n            \r\n            console.log(`Record ${index}:`, { sourceName, targetName, nodeName });\r\n\r\n            // Store node info (case-insensitive comparison)\r\n            if (sourceName && sourceName.toLowerCase() === nodeName.toLowerCase()) {\r\n              nodeInfo.name = sourceName;\r\n              nodeInfo.role = sourceRole;\r\n              nodeInfo.location = sourceLocation;\r\n              nodeInfo.website = sourceWebsite;\r\n              console.log(\"Found node info from source:\", { name: sourceName, role: sourceRole, location: sourceLocation });\r\n            } else if (targetName && targetName.toLowerCase() === nodeName.toLowerCase()) {\r\n              nodeInfo.name = targetName;\r\n              nodeInfo.role = targetRole;\r\n              nodeInfo.location = targetLocation;\r\n              nodeInfo.website = targetWebsite;\r\n              console.log(\"Found node info from target:\", { name: targetName, role: targetRole, location: targetLocation });\r\n            }\r\n\r\n            // Count connections\r\n            if (sourceName && targetName && sourceName !== targetName) {\r\n              const otherPerson = sourceName === nodeName ? targetName : sourceName;\r\n              const otherRole = sourceName === nodeName ? targetRole : sourceRole;\r\n              const otherLocation = sourceName === nodeName ? targetLocation : sourceLocation;\r\n              \r\n              connectedUsers.set(otherPerson, {\r\n                name: otherPerson,\r\n                role: otherRole,\r\n                location: otherLocation,\r\n                note: connectionNote,\r\n                time: connectionTime\r\n              });\r\n              \r\n              connections.push({\r\n                source: sourceName,\r\n                target: targetName,\r\n                note: connectionNote,\r\n                time: connectionTime\r\n              });\r\n            }\r\n          });\r\n\r\n          // Analyze connections\r\n          const totalConnections = connectedUsers.size;\r\n          const roles = Array.from(connectedUsers.values()).map(u => u.role).filter(Boolean);\r\n          const uniqueRoles = [...new Set(roles)];\r\n          const locations = Array.from(connectedUsers.values()).map(u => u.location).filter(Boolean);\r\n          const uniqueLocations = [...new Set(locations)];\r\n\r\n          // Find most common connections\r\n          const roleCounts = {};\r\n          roles.forEach(role => {\r\n            roleCounts[role] = (roleCounts[role] || 0) + 1;\r\n          });\r\n          const topRoles = Object.entries(roleCounts)\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 3);\r\n\r\n          const locationCounts = {};\r\n          locations.forEach(location => {\r\n            locationCounts[location] = (locationCounts[location] || 0) + 1;\r\n          });\r\n          const topLocations = Object.entries(locationCounts)\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 3);\r\n\r\n          console.log(\"Final nodeInfo:\", nodeInfo);\r\n          \r\n          // Generate the report\r\n          const report = `# 👤 **Individual Network Analysis: ${nodeName}**\r\n\r\n## **🎯 Profile Summary**\r\n- **Name**: ${nodeInfo.name || 'N/A'}\r\n- **Role**: ${nodeInfo.role || 'N/A'}\r\n- **Location**: ${nodeInfo.location || 'N/A'}\r\n- **Website**: ${nodeInfo.website || 'N/A'}\r\n- **Total Connections**: ${totalConnections}\r\n\r\n## **🔗 Connection Analysis**\r\n- **Network Reach**: ${totalConnections} direct connections\r\n- **Role Diversity**: ${uniqueRoles.length} different professional roles\r\n- **Geographic Reach**: ${uniqueLocations.length} different locations\r\n\r\n## **📊 Top Connection Categories**\r\n\r\n### **Most Connected Roles**\r\n${topRoles.map(([role, count]) => \r\n  `- **${role}**: ${count} connections`\r\n).join('\\n')}\r\n\r\n### **Most Connected Locations**\r\n${topLocations.map(([location, count]) => \r\n  `- **${location}**: ${count} connections`\r\n).join('\\n')}\r\n\r\n## **🌍 Network Diversity**\r\n- **Professional Diversity**: ${uniqueRoles.length} unique roles\r\n- **Geographic Diversity**: ${uniqueLocations.length} unique locations\r\n- **Connection Quality**: ${connections.filter(c => c.note).length} connections with notes\r\n\r\n## **💡 Key Insights**\r\n- ${nodeName} is a ${totalConnections > 20 ? 'super connector' : totalConnections > 10 ? 'active networker' : 'moderate connector'}\r\n- ${uniqueRoles.length > 3 ? 'High professional diversity' : 'Moderate professional diversity'} in connections\r\n- ${uniqueLocations.length > 5 ? 'Strong geographic reach' : 'Local to regional focus'} in networking\r\n\r\n## **🎯 Network Impact**\r\n- **Bridge Potential**: ${uniqueRoles.length > 2 && uniqueLocations.length > 3 ? 'High - connects diverse communities' : 'Moderate - focused connections'}\r\n- **Information Flow**: ${totalConnections > 15 ? 'Excellent - high connectivity' : totalConnections > 8 ? 'Good - moderate connectivity' : 'Limited - few connections'}\r\n- **Resource Sharing**: ${uniqueRoles.length > 2 ? 'Strong - diverse professional network' : 'Focused - similar professional backgrounds'}`;\r\n\r\n          return report;\r\n        };\r\n\r\n        // Helper function to display network reports\r\n        const displayNetworkReport = (report, question) => {\r\n          // Format the report with better styling\r\n          const formattedReport = report\r\n            .replace(/# 📊 \\*\\*Network Analysis Report\\*\\*/g, '<h1 style=\"color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;\">📊 Network Analysis Report</h1>')\r\n            .replace(/## \\*\\*🎯 Executive Summary\\*\\*/g, '<h2 style=\"color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 20px 0 15px 0;\">🎯 Executive Summary</h2>')\r\n            .replace(/## \\*\\*🏆 Top Network Connectors\\*\\*/g, '<h2 style=\"color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 20px 0 15px 0;\">🏆 Top Network Connectors</h2>')\r\n            .replace(/## \\*\\*🌍 Demographics & Participation\\*\\*/g, '<h2 style=\"color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 20px 0 15px 0;\">🌍 Demographics & Participation</h2>')\r\n            .replace(/## \\*\\*📈 Network Statistics\\*\\*/g, '<h2 style=\"color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 20px 0 15px 0;\">📈 Network Statistics</h2>')\r\n            .replace(/## \\*\\*💡 Key Insights\\*\\*/g, '<h2 style=\"color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 20px 0 15px 0;\">💡 Key Insights</h2>')\r\n            .replace(/## \\*\\*🎯 Recommendations\\*\\*/g, '<h2 style=\"color: #34495e; background: #ecf0f1; padding: 10px; border-radius: 5px; margin: 20px 0 15px 0;\">🎯 Recommendations</h2>')\r\n            .replace(/\\*\\*(.*?)\\*\\*/g, '<strong style=\"color: #e74c3c;\">$1</strong>')\r\n            .replace(/- \\*\\*(.*?)\\*\\*: (.*?)$/gm, '<li style=\"margin: 8px 0; padding: 5px 0; border-left: 3px solid #3498db; padding-left: 15px;\"><strong style=\"color: #e74c3c;\">$1</strong>: $2</li>')\r\n            .replace(/(\\d+)\\. \\*\\*(.*?)\\*\\* - (\\d+) connections/g, '<li style=\"margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid #27ae60;\"><strong style=\"color: #e74c3c;\">$2</strong> - <span style=\"color: #27ae60; font-weight: bold;\">$3 connections</span></li>')\r\n            .replace(/\\| (.*?) \\| (.*?) \\|/g, '<tr><td style=\"padding: 8px; border: 1px solid #ddd; background: #f8f9fa; font-weight: bold;\">$1</td><td style=\"padding: 8px; border: 1px solid #ddd; text-align: center;\">$2</td></tr>')\r\n            .replace(/\\|--------\\|-------\\|/g, '')\r\n            .replace(/- (.*?)$/gm, '<li style=\"margin: 5px 0; padding: 3px 0;\">$1</li>');\r\n\r\n          // Wrap in proper HTML structure\r\n          const htmlReport = `\r\n            <div style=\"\r\n              max-height: 70vh; \r\n              overflow-y: auto; \r\n              padding: 20px; \r\n              background: white; \r\n              border-radius: 8px; \r\n              box-shadow: 0 4px 6px rgba(0,0,0,0.1);\r\n              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n              line-height: 1.6;\r\n              color: #2c3e50;\r\n            \">\r\n              <div style=\"margin-bottom: 20px;\">\r\n                ${formattedReport}\r\n              </div>\r\n            </div>\r\n          `;\r\n\r\n          setAnalyticalAnswer({ \r\n            answer: htmlReport, \r\n            question: \"Network Analysis Report\",\r\n            isHtml: true \r\n          });\r\n          setShowAnalyticalModal(true);\r\n          \r\n          // Auto-hide after 30 seconds for reports (longer since it's more detailed)\r\n          setTimeout(() => {\r\n            setShowAnalyticalModal(false);\r\n            setAnalyticalAnswer(null);\r\n          }, 30000);\r\n        };\r\n\r\n\r\nreturn (\r\n    <div width=\"95%\">\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Show me all the MSEI students from CA\"\r\n        style={{ display: \"block\", width: \"95%\", height: \"40px\", margin: \"0 auto\", textAlign: \"center\", padding: \"8px\", border: \"1px solid #ccc\", borderRadius: \"4px\" }}\r\n        value={inputValue}\r\n        onChange={handleInputChange}\r\n        onKeyPress={(e) => {\r\n          if (e.key === 'Enter') {\r\n            e.preventDefault();\r\n            handleSubmit(e);\r\n          }\r\n        }}\r\n      />\r\n      <button id=\"visualize\" onClick={() => window.open(\"https://awuchen.github.io/greif-network-3d/\", \"_blank\")}>Visualize3D</button>\r\n      <button id=\"info\" onClick={() => window.open(\"https://www.hako.soooul.xyz/drafts/washi\", \"_blank\")}>Info</button>\r\n      <button \r\n        id=\"timeline\" \r\n        onClick={toggleTimelineMode}\r\n      >\r\n        {timelineMode ? 'Exit Timeline' : 'Timeline'}\r\n      </button>\r\n      \r\n      {/* Timeline Controls */}\r\n      {timelineMode && (\r\n        <div style={{\r\n          position: 'fixed',\r\n          bottom: '20px',\r\n          left: '50%',\r\n          transform: 'translateX(-50%)',\r\n          backgroundColor: 'white',\r\n          padding: '15px',\r\n          borderRadius: '8px',\r\n          boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\r\n          zIndex: 1000,\r\n          minWidth: '400px',\r\n          textAlign: 'center'\r\n        }}>\r\n          <h4 style={{ margin: '0 0 10px 0', color: '#333' }}>Network Timeline</h4>\r\n          <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '10px' }}>\r\n            <button\r\n              onClick={() => {\r\n                if (timelineDate) {\r\n                  const newDate = new Date(timelineDate.getTime() - 60000); // -1 minute\r\n                  updateTimelineDate(newDate);\r\n                }\r\n              }}\r\n              style={{\r\n                backgroundColor: '#2196F3',\r\n                color: 'white',\r\n                border: 'none',\r\n                padding: '4px 8px',\r\n                borderRadius: '4px',\r\n                cursor: 'pointer',\r\n                fontSize: '10px'\r\n              }}\r\n            >\r\n              -1m\r\n            </button>\r\n            <input\r\n              type=\"range\"\r\n              min={timelineStats?.earliest?.getTime() || Date.now() - 86400000} // Default to 24 hours ago if no earliest\r\n              max={timelineStats?.latest?.getTime() || Date.now()}\r\n              value={timelineDate?.getTime() || Date.now()}\r\n              step={60000} // 1 minute steps (60,000 milliseconds)\r\n              onChange={(e) => {\r\n                const timestamp = parseInt(e.target.value);\r\n                const date = new Date(timestamp);\r\n                updateTimelineDate(date);\r\n              }}\r\n              style={{ flex: 1 }}\r\n            />\r\n            <button\r\n              onClick={() => {\r\n                if (timelineDate) {\r\n                  const newDate = new Date(timelineDate.getTime() + 60000); // +1 minute\r\n                  updateTimelineDate(newDate);\r\n                }\r\n              }}\r\n              style={{\r\n                backgroundColor: '#2196F3',\r\n                color: 'white',\r\n                border: 'none',\r\n                padding: '4px 8px',\r\n                borderRadius: '4px',\r\n                cursor: 'pointer',\r\n                fontSize: '10px'\r\n              }}\r\n            >\r\n              +1m\r\n            </button>\r\n            <span style={{ fontSize: '12px', color: '#666', minWidth: '120px' }}>\r\n              {timelineDate ? `${timelineDate.toLocaleDateString()} ${timelineDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}` : 'Current Time'}\r\n            </span>\r\n          </div>\r\n          <div style={{ display: 'flex', gap: '10px', justifyContent: 'center', marginBottom: '10px' }}>\r\n            <button\r\n              onClick={() => {\r\n                if (timelineDate) {\r\n                  const newDate = new Date(timelineDate.getTime() - 300000); // -5 minutes\r\n                  updateTimelineDate(newDate);\r\n                }\r\n              }}\r\n              style={{\r\n                backgroundColor: '#4CAF50',\r\n                color: 'white',\r\n                border: 'none',\r\n                padding: '4px 8px',\r\n                borderRadius: '4px',\r\n                cursor: 'pointer',\r\n                fontSize: '10px'\r\n              }}\r\n            >\r\n              -5m\r\n            </button>\r\n\r\n            <button\r\n              onClick={() => loadTimelineData(new Date())}\r\n              style={{\r\n                backgroundColor: '#9C27B0',\r\n                color: 'white',\r\n                border: 'none',\r\n                padding: '6px 12px',\r\n                borderRadius: '4px',\r\n                cursor: 'pointer',\r\n                fontSize: '12px'\r\n              }}\r\n            >\r\n              Load Current\r\n            </button>\r\n            <button\r\n              onClick={() => {\r\n                if (timelineDate) {\r\n                  const newDate = new Date(timelineDate.getTime() + 300000); // +5 minutes\r\n                  updateTimelineDate(newDate);\r\n                }\r\n              }}\r\n              style={{\r\n                backgroundColor: '#4CAF50',\r\n                color: 'white',\r\n                border: 'none',\r\n                padding: '4px 8px',\r\n                borderRadius: '4px',\r\n                cursor: 'pointer',\r\n                fontSize: '10px'\r\n              }}\r\n            >\r\n              +5m\r\n            </button>\r\n          </div>\r\n          {timelineData && (\r\n            <div style={{ fontSize: '11px', color: '#666', display: 'flex', justifyContent: 'space-between' }}>\r\n              <span>Nodes: {timelineData.nodes.length}</span>\r\n              <span>Connections: {timelineData.links.length}</span>\r\n              <span>Time: {timelineDate?.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'})}</span>\r\n            </div>\r\n          )}\r\n          {timelineStats && (\r\n            <div style={{ fontSize: '10px', color: '#999', marginTop: '8px', textAlign: 'center' }}>\r\n              Timeline: {timelineStats.earliest?.toLocaleDateString()} {timelineStats.earliest?.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} \r\n              to {timelineStats.latest?.toLocaleDateString()} {timelineStats.latest?.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Mutation processing indicator */}\r\n      {processingMutation && (\r\n        <div style={{\r\n          position: \"fixed\",\r\n          top: \"60px\",\r\n          right: \"10px\",\r\n          padding: \"8px 12px\",\r\n          backgroundColor: \"#9C27B0\",\r\n          color: \"white\",\r\n          borderRadius: \"4px\",\r\n          fontSize: \"12px\",\r\n          zIndex: 1000,\r\n          display: \"flex\",\r\n          alignItems: \"center\",\r\n          gap: \"8px\"\r\n        }}>\r\n          <div style={{\r\n            width: \"8px\",\r\n            height: \"8px\",\r\n            borderRadius: \"50%\",\r\n            backgroundColor: \"#fff\",\r\n            animation: \"pulse 0.5s infinite\"\r\n          }}></div>\r\n          Processing Mutation...\r\n        </div>\r\n      )}\r\n\r\n      {/* Analytical Answer Modal */}\r\n      {showAnalyticalModal && analyticalAnswer && (\r\n        <div \r\n          style={{ \r\n            position: \"absolute\", \r\n            top: \"50%\", \r\n            left: \"50%\", \r\n            transform: \"translate(-50%, -50%)\", \r\n            width: \"80%\", \r\n            maxWidth: \"800px\",\r\n            maxHeight: \"80vh\",\r\n            backgroundColor: \"white\", \r\n            border: \"2px solid #3498db\", \r\n            borderRadius: \"10px\",\r\n            boxShadow: \"0px 0px 20px rgba(0, 0, 0, 0.3)\", \r\n            zIndex: 1000,\r\n            overflow: \"hidden\"\r\n          }}\r\n          onClick={(e) => e.stopPropagation()}\r\n        >\r\n          <div style={{\r\n            padding: \"15px 20px\",\r\n            backgroundColor: \"#3498db\",\r\n            color: \"white\",\r\n            display: \"flex\",\r\n            justifyContent: \"space-between\",\r\n            alignItems: \"center\"\r\n          }}>\r\n            <h3 style={{ margin: 0, fontSize: \"18px\" }}>{analyticalAnswer.question}</h3>\r\n            <button \r\n              onClick={() => {\r\n                setShowAnalyticalModal(false);\r\n                setAnalyticalAnswer(null);\r\n              }}\r\n              style={{\r\n                background: \"none\",\r\n                border: \"none\",\r\n                color: \"white\",\r\n                fontSize: \"20px\",\r\n                cursor: \"pointer\",\r\n                padding: \"0\",\r\n                width: \"30px\",\r\n                height: \"30px\",\r\n                display: \"flex\",\r\n                alignItems: \"center\",\r\n                justifyContent: \"center\"\r\n              }}\r\n            >\r\n              ×\r\n            </button>\r\n          </div>\r\n          <div style={{ padding: \"0\", maxHeight: \"calc(80vh - 60px)\", overflow: \"hidden\" }}>\r\n            {analyticalAnswer.isHtml ? (\r\n              <div dangerouslySetInnerHTML={{ __html: analyticalAnswer.answer }} />\r\n            ) : (\r\n              <div style={{ padding: \"20px\", maxHeight: \"calc(80vh - 60px)\", overflowY: \"auto\" }}>\r\n          <p><strong>Answer:</strong> {analyticalAnswer.answer}</p>\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n      )}\r\n      \r\n\r\n      \r\n      <style>{`\r\n        @keyframes pulse {\r\n          0% { opacity: 1; }\r\n          50% { opacity: 0.5; }\r\n          100% { opacity: 1; }\r\n        }\r\n        \r\n        @keyframes breathe {\r\n          0%, 100% { \r\n            transform: scale(1);\r\n            opacity: 1;\r\n          }\r\n          50% { \r\n            transform: scale(1.5);\r\n            opacity: 0.7;\r\n          }\r\n        }\r\n      `}</style>\r\n\r\n  <ForceGraph2D\r\n  ref={fgRef}\r\n  graphData={timelineMode && timelineData ? timelineData : data}\r\n  nodeId=\"name\"\r\n  nodeLabel={(node) => node.role || \"No Program Specified\"}\r\n  linkLabel={(link) => {\r\n    if (hoveredLink && hoveredLink.link === link) {\r\n      return hoveredLink.note || \"No note added\";\r\n    }\r\n    return null;\r\n  }}\r\n\r\n  onNodeClick={handleNodeClick}\r\n  onNodeHover={handleNodeHover}\r\n  onLinkClick={handleLinkClick}\r\n  onLinkHover={handleLinkHover}\r\n\r\n  onBackgroundClick={() => {\r\n    setFocusNode(null);\r\n    setClickedNode(null);\r\n    setLastAction(null);\r\n    setMutatedNodes([]);\r\n    setSelectedNode(null);\r\n    setShowAnalyticalModal(false);\r\n    setAnalyticalAnswer(null);\r\n    setSelectedLink(null);\r\n    setRelationshipData({});\r\n    \r\n    // Clear any active focus timeouts when background is clicked\r\n    // Note: focusTimeout is managed in GraphView component, so we don't need to clear it here\r\n  }}\r\n  nodeCanvasObject={(node, ctx) => {\r\n    const isHighlighted =\r\n      inputValue &&\r\n      (node.name.toLowerCase().includes(inputValue.toLowerCase()) ||\r\n        (node.location && node.location.toLowerCase().includes(inputValue.toLowerCase())) ||\r\n        (node.role && node.role.toLowerCase().includes(inputValue.toLowerCase())) ||\r\n        (node.website && node.website.toLowerCase().includes(inputValue.toLowerCase())));\r\n    const isNDegree = visibilityNodes.has(node.name);\r\n\r\n    ctx.globalAlpha = isNDegree ? 1.0 : 0.2;\r\n    \r\n    // Add breathing effect when user is idle or transitioning\r\n    let nodeRadius = 6;\r\n    const now = Date.now();\r\n    \r\n    // Frame rate optimization: only update every 60ms (16fps) for better performance\r\n    const frameRate = 60;\r\n    const time = Math.floor(now / frameRate) * frameRate * 0.001;\r\n    \r\n    if (!isUserActive) {\r\n      // Optimized breathing effect with cached calculations\r\n      // Use a simpler sine wave with reduced frequency for better performance\r\n      const breathingScale = 1 + 0.1 * Math.sin(time * 0.8); // Reduced frequency from 1.5 to 0.8\r\n      nodeRadius = 6 * breathingScale;\r\n    } else if (scaleTransitionStart && (now - scaleTransitionStart) < scaleTransitionDuration) {\r\n      // Optimized transition with cached calculations\r\n      const transitionProgress = Math.min((now - scaleTransitionStart) / scaleTransitionDuration, 1);\r\n      // Cache the breathing scale calculation\r\n      const breathingScale = 1 + 0.1 * Math.sin((scaleTransitionStart * 0.001) * 0.8);\r\n      const targetScale = 1;\r\n      const currentScale = breathingScale + (targetScale - breathingScale) * transitionProgress;\r\n      nodeRadius = 6 * currentScale;\r\n    }\r\n    \r\n    // Use latestNode for editing (black), pollingFocusNode for viewing (green), clickedNode for selection (gray), or white for normal\r\n    // Visual states persist even after focus period ends\r\n    let fillColor = \"white\";\r\n    if (node.name === latestNode) {\r\n      fillColor = \"black\"; // Editable node - persists after focus\r\n    } else if (node.name === pollingFocusNode) {\r\n      fillColor = \"green\"; // Non-editable polling focus - persists after focus\r\n    } else if (node.name === clickedNode) {\r\n      fillColor = \"gray\"; // Clicked node - persists after focus\r\n    }\r\n    \r\n    // Add subtle color shift during breathing animation\r\n    if (!isUserActive && fillColor === \"white\") {\r\n      // Optimized color shift with reduced frequency and frame rate optimization\r\n      const colorShift = Math.sin(time * 0.8) * 0.1;\r\n      // Shift towards a very light blue during breathing\r\n      fillColor = `rgb(${255 + colorShift * 50}, ${255 + colorShift * 30}, ${255 + colorShift * 100})`;\r\n    } else if (scaleTransitionStart && (now - scaleTransitionStart) < scaleTransitionDuration && fillColor === \"white\") {\r\n      // Optimized color transition with cached calculations\r\n      const transitionProgress = (now - scaleTransitionStart) / scaleTransitionDuration;\r\n      // Cache the color shift calculation\r\n      const lastColorShift = Math.sin((scaleTransitionStart * 0.001) * 0.8) * 0.1;\r\n      const currentColorShift = lastColorShift * (1 - transitionProgress);\r\n      fillColor = `rgb(${255 + currentColorShift * 50}, ${255 + currentColorShift * 30}, ${255 + currentColorShift * 100})`;\r\n    }\r\n    \r\n    // Add subtle glow effect during breathing animation\r\n    // Removed shadow and alpha effects for performance\r\n    \r\n    ctx.fillStyle = fillColor;\r\n    ctx.strokeStyle = isHighlighted ? \"red\" : \"black\";\r\n    ctx.lineWidth = isHighlighted ? 3 : 2;\r\n\r\n    ctx.beginPath();\r\n    ctx.arc(node.x || Math.random() * 500, node.y || Math.random() * 500, nodeRadius, 0, 2 * Math.PI);\r\n    ctx.fill();\r\n    ctx.stroke();\r\n\r\n    // Reset shadow for text\r\n    ctx.shadowBlur = 0;\r\n    ctx.fillStyle = \"gray\";\r\n    \r\n    // Extract first name from full name\r\n    const firstName = node.name.split(' ')[0];\r\n    ctx.fillText(firstName, node.x + 10, node.y);\r\n\r\n    ctx.globalAlpha = 1.0; // Reset alpha for next node\r\n  }}\r\n  linkColor={(link) => {\r\n    const sourceName = typeof link.source === 'object' ? link.source.name : link.source;\r\n    const targetName = typeof link.target === 'object' ? link.target.name : link.target;\r\n    const isConnected = visibilityNodes.has(sourceName) && visibilityNodes.has(targetName);\r\n    \r\n    // Check if this link is being hovered\r\n    const isHovered = hoveredLink && hoveredLink.link === link;\r\n    \r\n    if (isHovered) {\r\n      return '#000'; // Black when hovered\r\n    }\r\n    \r\n    return isConnected ? '#999' : '#ccc';\r\n  }}\r\n  linkOpacity={(link) => {\r\n    const sourceName = typeof link.source === 'object' ? link.source.name : link.source;\r\n    const targetName = typeof link.target === 'object' ? link.target.name : link.target;\r\n    const isConnected = visibilityNodes.has(sourceName) && visibilityNodes.has(targetName);\r\n    return isConnected ? 1.0 : 0.15;\r\n  }}\r\n\r\n  linkCurvature={0.2}\r\n  linkDirectionalArrowRelPos={1}\r\n  linkDirectionalArrowLength={5}\r\n  />\r\n\r\n  {/* NFC Name Input Popup */}\r\n  {showNfcNamePopup && (\r\n    <div \r\n      style={{ position: \"absolute\", top: \"20%\", left: \"50%\", transform: \"translate(-50%, -50%)\", padding: \"20px\", backgroundColor: \"white\", border: \"1px solid black\", boxShadow: \"0px 0px 10px rgba(0, 0, 0, 0.3)\", zIndex: 1000, minWidth: \"300px\" }}\r\n      onClick={(e) => e.stopPropagation()}\r\n    >\r\n      <h3>Enter Info</h3>\r\n      <p><strong>Name:</strong>\r\n      <input \r\n        value={nfcNameInput} \r\n        onChange={(e) => setNfcNameInput(e.target.value)}\r\n        placeholder=\"Enter your name\" \r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\" }}\r\n        onKeyPress={(e) => {\r\n          if (e.key === 'Enter') {\r\n            handleNfcNameSubmit();\r\n          }\r\n        }}\r\n      /></p>\r\n\r\n      <p><strong>Program:</strong>\r\n      <input \r\n        value={nfcRoleInput} \r\n        onChange={(e) => setNfcRoleInput(e.target.value)}\r\n        placeholder=\"e.g., MSEI, MSSE, MSBA, MBA, etc.\" \r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\" }}\r\n        onKeyPress={(e) => {\r\n          if (e.key === 'Enter') {\r\n            handleNfcNameSubmit();\r\n          }\r\n        }}\r\n      /></p>\r\n\r\n      <p><button onClick={handleNfcNameSubmit} style={{ marginRight: \"10px\", padding: \"8px 16px\" }}>Continue</button>\r\n      <button onClick={() => {\r\n        setShowNfcNamePopup(false);\r\n        setNfcNameInput(\"\");\r\n        setNfcRoleInput(\"\");\r\n      }} style={{ padding: \"8px 16px\" }}>Cancel</button></p>\r\n    </div>\r\n  )}\r\n\r\n  {/* Profile Completion Popup (for new nodes) */}\r\n  {showProfilePopup && selectedNode && editedNode && (\r\n    <div \r\n      style={{ position: \"absolute\", top: \"20%\", left: \"50%\", transform: \"translate(-50%, -50%)\", padding: \"20px\", backgroundColor: \"white\", border: \"1px solid black\", boxShadow: \"0px 0px 10px rgba(0, 0, 0, 0.3)\", zIndex: 1000, minWidth: \"300px\" }}\r\n      onClick={(e) => e.stopPropagation()}\r\n    >\r\n      <h3>Complete Your Profile</h3>\r\n      <p><strong>Name:</strong>\r\n      <input \r\n      name=\"name\" \r\n      value={editedNode.name} \r\n        placeholder=\"Enter your name\" \r\n      onChange={handleEditChange}\r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\" }}\r\n      /></p>\r\n\r\n      <p><strong>Program:</strong>\r\n      <input \r\n        name=\"role\" \r\n        value={editedNode.role || \"\"} \r\n        placeholder=\"e.g., MSEI, MBA, BS, MS, PhD\" \r\n        onChange={handleEditChange}\r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\" }}\r\n      /></p>\r\n\r\n      <p><strong>Location:</strong>\r\n      <input \r\n        name=\"location\" \r\n        value={editedNode.location || \"\"} \r\n        placeholder=\"e.g., Los Angeles, CA\" \r\n        onChange={handleEditChange}\r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\" }}\r\n      /></p>\r\n\r\n      <p><strong>Email/Website:</strong>\r\n      <input \r\n        name=\"website\" \r\n        value={editedNode.website || \"\"} \r\n        placeholder=\"your.email@example.com\" \r\n        onChange={handleEditChange}\r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\" }}\r\n      /></p>\r\n\r\n      <p><button onClick={saveNewProfileFromNfc} style={{ marginRight: \"10px\", padding: \"8px 16px\" }}>Save Profile</button>\r\n      <button onClick={() => setShowProfilePopup(false)} style={{ padding: \"8px 16px\" }}>Cancel</button></p>\r\n    </div>\r\n  )}\r\n\r\n  {/* Regular Node Info Popup (for clicking on any node) */}\r\n  {selectedNode && !showProfilePopup && !showNfcNamePopup && !showNfcRelationshipPopup && (\r\n    <div \r\n      style={{ position: \"absolute\", top: \"20%\", left: \"50%\", transform: \"translate(-50%, -50%)\", padding: \"20px\", backgroundColor: \"white\", border: \"1px solid black\", boxShadow: \"0px 0px 10px rgba(0, 0, 0, 0.3)\", zIndex: 1000, minWidth: \"300px\" }}\r\n      onClick={(e) => e.stopPropagation()}\r\n    >\r\n      <h3>Network Info</h3>\r\n      <p><strong>Name:</strong> {selectedNode?.name}</p>\r\n      {selectedNode?.role && <p><strong>Program:</strong> {selectedNode.role}</p>}\r\n      {selectedNode?.location && <p><strong>Location:</strong> {selectedNode.location}</p>}\r\n      {selectedNode?.website && <p><strong>Email:</strong>{\" \"}\r\n        <a href={`mailto:${selectedNode.website}`}>\r\n        {selectedNode.website.length > 30 \r\n          ? `${selectedNode.website.substring(0, 30)}...`\r\n        : selectedNode.website}\r\n        </a>\r\n      </p>}\r\n      \r\n\r\n    </div>\r\n  )}\r\n\r\n  {/* NFC Relationship Note Popup (only during NFC flow) */}\r\n  {showNfcRelationshipPopup && selectedNode && (\r\n    <div \r\n      style={{ position: \"absolute\", top: \"20%\", left: \"50%\", transform: \"translate(-50%, -50%)\", padding: \"20px\", backgroundColor: \"white\", border: \"1px solid black\", boxShadow: \"0px 0px 10px rgba(0, 0, 0, 0.3)\", zIndex: 1000, minWidth: \"300px\" }}\r\n      onClick={(e) => e.stopPropagation()}\r\n    >\r\n      <h3>Add Connection Note</h3>\r\n      <p><strong>Connected to:</strong> {selectedNode?.name}</p>\r\n      {selectedNode?.role && <p><strong>Program:</strong> {selectedNode.role}</p>}\r\n      {selectedNode?.location && <p><strong>Location:</strong> {selectedNode.location}</p>}\r\n      {selectedNode?.website && <p><strong>Email:</strong>{\" \"}\r\n        <a href={`mailto:${selectedNode.website}`}>\r\n          {selectedNode.website.length > 30 \r\n            ? `${selectedNode.website.substring(0, 30)}...`\r\n          : selectedNode.website}\r\n        </a>\r\n      </p>}\r\n      \r\n      <p><strong>Note:</strong>\r\n      <textarea \r\n        value={relationshipNote} \r\n        onChange={(e) => setRelationshipNote(e.target.value)}\r\n        placeholder=\"e.g., Met at USC networking event, Introduced by mutual friend, Worked together on project...\"\r\n        style={{ width: \"100%\", marginTop: \"5px\", padding: \"5px\", minHeight: \"80px\", resize: \"vertical\" }}\r\n      /></p>\r\n\r\n      <p><button onClick={saveRelationshipNote} style={{ padding: \"8px 16px\" }}>Save</button></p>\r\n    </div>\r\n  )}\r\n\r\n  {/* Relationship Note Popup */}\r\n  {selectedLink && relationshipData && (\r\n    <div \r\n      style={{ position: \"absolute\", top: \"30%\", left: \"50%\", transform: \"translate(-50%, -50%)\", padding: \"20px\", backgroundColor: \"white\", border: \"1px solid black\", boxShadow: \"0px 0px 10px rgba(0, 0, 0, 0.3)\", zIndex: 1000, minWidth: \"300px\" }}\r\n      onClick={(e) => e.stopPropagation()}\r\n    >\r\n      <h3>Connection Details</h3>\r\n      <p><strong>From:</strong> {relationshipData.sourceName}</p>\r\n      <p><strong>To:</strong> {relationshipData.targetName}</p>\r\n      \r\n      {relationshipData.note ? (\r\n        <>\r\n          <p><strong>Note:</strong></p>\r\n          <div style={{ \r\n            backgroundColor: \"#f5f5f5\", \r\n            padding: \"10px\", \r\n            borderRadius: \"4px\", \r\n            marginTop: \"5px\",\r\n            fontStyle: \"italic\"\r\n          }}>\r\n            \"{relationshipData.note}\"\r\n          </div>\r\n        </>\r\n      ) : (\r\n        <p style={{ color: \"#666\", fontStyle: \"italic\" }}>No note added yet.</p>\r\n      )}\r\n      \r\n\r\n    </div>\r\n  )}\r\n\r\n\r\n\r\n  </div>\r\n  );\r\n    };\r\n\r\n    export default CypherViz;\r\n\r\n","import React from 'react';\r\nimport './App.css';\r\nimport CypherViz from './CypherViz';\r\n\r\nfunction App({driver}) {\r\n  return (\r\n    <div className=\"App\">\r\n      <CypherViz driver={driver}></CypherViz>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport * as neo4j from  'neo4j-driver';\r\n\r\nconst driver = neo4j.driver(\r\n  process.env.NEO4J_URI || 'neo4j+s://f2f86513.databases.neo4j.io',\r\n  neo4j.auth.basic(\r\n    process.env.NEO4J_USER || 'neo4j',\r\n    process.env.NEO4J_PASSWORD || 'L3mEQh9heKy6GlV8riaaI63BdsuNq6O9_GozSesfQXM'\r\n  ),\r\n  {\r\n    //encrypted: process.env.NEO4J_ENCRYPTED ? 'ENCRYPTION_ON' : 'ENCRYPTION_OFF',\r\n    //encrypted: process.env.NEO4J_ENCRYPTED = 'ENCRYPTION_ON',\r\n  }\r\n)\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App driver={driver}/>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}